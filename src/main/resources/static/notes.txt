def extract_ticket_and_guid(email_body: str):
    """Extract Jira ticket ID and Thread ID from email body"""
    jira_pattern = r'https://jira3\.horizon\.bankofamerica\.com/browse/([A-Z]+-\d+)'
    guid_pattern = r'Thread ID: ([\w-]+)'

    jira_match = re.search(jira_pattern, email_body)
    guid_match = re.search(guid_pattern, email_body)

    jira_key = jira_match.group(1) if jira_match else None
    guid = guid_match.group(1) if guid_match else None

    return jira_key, guid

def find_email_thread_attachment(issue, guid):
    """Find the email thread attachment for given GUID"""
    for attachment in issue.fields.attachment:
        # Look for attachment with matching GUID in filename
        if f"email_thread_{guid}" in attachment.filename:
            return attachment.id
    return None

def update_email_thread_attachment(jira, issue_key, html_content, guid):
    """Update email thread attachment with new content"""
    issue = jira.issue(issue_key)

    # Find and delete old attachment
    old_attachment_id = find_email_thread_attachment(issue, guid)
    if old_attachment_id:
        jira.delete_attachment(old_attachment_id)

    # Add new attachment
    attachment_name = f"email_thread_{guid}.html"
    issue.add_attachment(
        attachment=html_content.encode('utf-8'),
        filename=attachment_name
    )

def create_response_email(mail, jira_key):
    """Create formatted email response with GUID"""
    guid = str(uuid.uuid4())

    response_body = (
        "Thank you for reaching out to Enterprise Developer Tooling.\n"  # First line
        "\n"  # Empty line
        "A ticket has been created for your reference:\n"  # Second line
        f"Jira Ticket: https://jira3.horizon.bankofamerica.com/browse/{jira_key}\n"  # Third line
        f"Thread ID: {guid}\n"  # Fourth line
        "\n"  # Empty line
        "Please feel free to comment on the ticket if you would like to leave feedback.\n"  # Fifth line
        "\n"  # Empty line
        "Best regards,\n"  # Sixth line
        "Enterprise Developer Tooling Team"  # Seventh line
    )

    # Create the email reply
    mail.create_reply_all(
        subject="Re: " + mail.subject,
        body=response_body
    )

    return guid

import uuid
import re

def generate_guid():
    """Generate a simple GUID"""
    return str(uuid.uuid4())

def add_guid_to_body(body, guid=None):
    """Add GUID to email body"""
    if guid is None:
        guid = generate_guid()
    guid_line = f"\n\nReference ID: {guid}\n"
    return body + guid_line

def extract_guid_from_body(body):
    """Extract GUID from email body if present"""
    pattern = r'Reference ID: ([\w-]+)'
    match = re.search(pattern, body)
    return match.group(1) if match else None

# Example usage:
original_body = """
Thank you for contacting IT Support.
Your ticket has been created and we will get back to you shortly.

Best regards,
IT Support Team
"""

# Adding GUID to email response
response_body = add_guid_to_body(original_body)
print("Email body with GUID:")
print(response_body)

# Later, when receiving a reply, extract the GUID
extracted_guid = extract_guid_from_body(response_body)
print(f"\nExtracted GUID: {extracted_guid}")

def setup_logging():
    log_folder = os.path.join(os.getcwd(), 'logs')

    if not os.path.exists(log_folder):
        os.makedirs(log_folder)

    log_file = os.path.join(log_folder, 'app.log')
    handler = RotatingFileHandler(log_file, maxBytes=10*1024*1024, backupCount=5)
    handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')
    handler.setFormatter(formatter)

    # Set up root logger
    logging.getLogger().setLevel(logging.INFO)
    logging.getLogger().addHandler(handler)

# File: setup.py
import json
from setuptools import setup, find_packages

# Read the contents of your README file
with open('README.md', 'r', encoding='utf-8') as f:
    long_description = f.read()

# Read the contents of your setup.json file
with open('setup.json', 'r') as f:
    config = json.load(f)

# Read the contents of your requirements.txt file
with open('requirements.txt', 'r') as f:
    requirements = f.read().splitlines()

setup(
    name=config['name'],
    version=config['version'],
    author=config.get('author', ''),
    author_email=config.get('author_email', ''),
    description=config.get('description', ''),
    long_description=long_description,
    long_description_content_type='text/markdown',
    url=config.get('url', ''),
    package_dir={"": "src"},
    packages=find_packages(where="src"),
    include_package_data=True,
    install_requires=requirements,
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
    entry_points={
        'console_scripts': [
            'edt-service=edt_service.app:main',
        ],
    },
)



# File: MANIFEST.in
include README.md
include requirements.txt
include setup.json
recursive-include src/edt_service/templates *
recursive-include src/edt_service/static *

import logging
from queue import Queue
from threading import Thread
from jira import JIRA
from tqdm import tqdm
import time

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='jira_cleanup.log',
    filemode='w'
)

# Add console handler if you want to see logs in console as well
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logging.getLogger('').addHandler(console)

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets
JQL_QUERY = '''
    project = DLAB
    AND issuekey >= DLAB-1651
    AND issuekey <= DLAB-12500
    AND summary ~ "Your specific text here"
'''

CANCELLED_RESOLUTION = "Cancelled"
CUSTOM_COMMENT = "This issue has been automatically closed as part of a cleanup process."

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except Exception as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except Exception as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def process_ticket(jira, issue):
    start_time = time.time()
    try:
        # Your existing process_ticket logic here
        # For example:
        jira.transition_issue(issue, 'Open')
        time.sleep(1)
        jira.transition_issue(issue, 'Close', fields={'resolution': {'name': CANCELLED_RESOLUTION}})
        jira.add_comment(issue, CUSTOM_COMMENT)
        # Detach from epic logic here

        end_time = time.time()
        processing_time = end_time - start_time
        logging.info(f"Processed ticket {issue.key} in {processing_time:.2f} seconds")
    except Exception as e:
        end_time = time.time()
        processing_time = end_time - start_time
        logging.error(f"Error processing ticket {issue.key} after {processing_time:.2f} seconds: {str(e)}")

def worker(jira, queue, progress_bar):
    while True:
        issue = queue.get()
        if issue is None:
            break
        try:
            process_ticket(jira, issue)
        except Exception as e:
            logging.error(f"Error in worker thread for ticket {issue.key}: {str(e)}")
        finally:
            queue.task_done()
            progress_bar.update(1)

def main():
    overall_start_time = time.time()

    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    queue = Queue()
    for issue in issues:
        queue.put(issue)

    num_threads = 10
    progress_bar = tqdm(total=len(issues), desc="Processing tickets")

    threads = []
    for _ in range(num_threads):
        thread = Thread(target=worker, args=(jira, queue, progress_bar))
        thread.start()
        threads.append(thread)

    queue.join()

    for _ in range(num_threads):
        queue.put(None)
    for thread in threads:
        thread.join()

    progress_bar.close()

    overall_end_time = time.time()
    total_time = overall_end_time - overall_start_time
    logging.info(f"Total processing time: {total_time:.2f} seconds")
    logging.info(f"Average time per ticket: {total_time / len(issues):.2f} seconds")

if __name__ == "__main__":
    main()

def add_comment(jira, issue):
    try:
        jira.add_comment(issue, CUSTOM_COMMENT)
        logging.info(f"Added comment to ticket {issue.key}")
        return True
    except JIRAError as e:
        logging.error(f"Failed to add comment to ticket {issue.key}: {str(e)}")
        return False


from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging
import time

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

# Define the resolution
CANCELLED_RESOLUTION = "Cancelled"

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def transition_to_open(jira, issue):
    try:
        jira.transition_issue(issue, 'Open')
        logging.info(f"Transitioned ticket {issue.key} to 'Open'")
        return True
    except JIRAError as e:
        logging.error(f"Failed to transition ticket {issue.key} to 'Open': {str(e)}")
        return False

def close_with_cancelled_resolution(jira, issue):
    try:
        jira.transition_issue(issue, 'Close', fields={'resolution': {'name': CANCELLED_RESOLUTION}})
        logging.info(f"Closed ticket {issue.key} with 'Cancelled' resolution")
        return True
    except JIRAError as e:
        logging.error(f"Failed to close ticket {issue.key} with 'Cancelled' resolution: {str(e)}")
        return False

def detach_from_epic(jira, issue):
    try:
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
            return True
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to detach ticket {issue.key} from EPIC: {str(e)}")
        return False

def process_ticket(jira, issue):
    # Step 1: Transition to "Open"
    if transition_to_open(jira, issue):
        time.sleep(1)  # Wait a short time to allow JIRA to process the transition

        # Step 2: Close with "Cancelled" resolution
        if close_with_cancelled_resolution(jira, issue):
            # Step 3: Detach from EPIC
            detach_from_epic(jira, issue)
        else:
            logging.warning(f"Could not close ticket {issue.key} with 'Cancelled' resolution")
    else:
        logging.warning(f"Could not open ticket {issue.key}. It may already be in the desired state.")

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        process_ticket(jira, issue)

if __name__ == "__main__":
    main()

from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging
import time

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def transition_issue(jira, issue, transition_name):
    try:
        transitions = jira.transitions(issue)
        transition_id = next((t['id'] for t in transitions if t['name'].lower() == transition_name.lower()), None)

        if transition_id:
            jira.transition_issue(issue, transition_id)
            logging.info(f"Transitioned ticket {issue.key} to '{transition_name}'")
            return True
        else:
            logging.warning(f"No '{transition_name}' transition found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to transition ticket {issue.key} to '{transition_name}': {str(e)}")
        return False

def detach_from_epic(jira, issue):
    try:
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
            return True
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to detach ticket {issue.key} from EPIC: {str(e)}")
        return False

def process_ticket(jira, issue):
    # Step 1: Transition to "Open"
    if transition_issue(jira, issue, "Open"):
        # Wait a short time to allow JIRA to process the first transition
        time.sleep(1)

        # Step 2: Transition to "Close"
        if transition_issue(jira, issue, "Close"):
            # Step 3: Detach from EPIC
            detach_from_epic(jira, issue)
        else:
            logging.warning(f"Could not close ticket {issue.key}")
    else:
        logging.warning(f"Could not open ticket {issue.key}. It may already be in the desired state.")

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        process_ticket(jira, issue)

if __name__ == "__main__":
    main()

from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def cancel_and_detach_from_epic(jira, issue):
    try:
        # Find the 'Cancel' transition ID
        transitions = jira.transitions(issue)
        cancel_transition_id = next((t['id'] for t in transitions if t['name'].lower() == 'cancel'), None)

        if cancel_transition_id:
            jira.transition_issue(issue, cancel_transition_id)
            logging.info(f"Cancelled ticket {issue.key}")
        else:
            logging.warning(f"No 'Cancel' transition found for {issue.key}")

        # Detach from EPIC
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")

        return True
    except JIRAError as e:
        logging.error(f"Failed to cancel and detach ticket {issue.key}: {str(e)}")
        return False

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        cancel_and_detach_from_epic(jira, issue)

if __name__ == "__main__":
    main()

import json
from setuptools import setup, find_packages

# Load setup configuration from setup.json
with open("setup.json", "r") as f:
    setup_config = json.load(f)

# Load dependencies from requirements.txt
with open("requirements.txt", "r") as f:
    install_requires = f.read().splitlines()

setup(
    name=setup_config["name"],
    version=setup_config["version"],
    description=setup_config["description"],
    author=setup_config["author"],
    author_email=setup_config["author_email"],
    url=setup_config["url"],
    packages=find_packages(include=["*"]),
    install_requires=install_requires,
    include_package_data=True,
    package_data={
        '': ['*.html'],  # Include HTML templates
    },
    entry_points={
        'console_scripts': [
            'run-flask-app=your_module.your_entry_file:main',  # Define the entry point
        ],
    },
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
)


[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "your-package-name"
version = "0.1.0"
description = "A description of your Python package"
authors = [
    {name = "Your Name", email = "your.email@example.com"},
]
dependencies = [
    "requests",
    "numpy",
]
readme = "README.md"
requires-python = ">=3.6"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]

[tool.setuptools.packages.find]
where = ["."]
include = ["*"]

[tool.setuptools.package-data]
"your_package_name" = ["*.html"]  # Include HTML templates, adjust this to your needs

[project.scripts]
run-flask-app = "your_package_name.your_entry_file:main"


from transformers import T5Tokenizer, T5ForConditionalGeneration

# Load the T5-small model and tokenizer
model_path = 'path/to/your/t5-small'  # Update this with the path to your downloaded model
tokenizer = T5Tokenizer.from_pretrained(model_path)
model = T5ForConditionalGeneration.from_pretrained(model_path)

def summarize_questions(questions):
    # Combine all questions into a single string
    input_text = " ".join(questions)
    input_text = "summarize: " + input_text  # Prefix for T5

    # Encode the input text
    inputs = tokenizer.encode(input_text, return_tensors='pt', max_length=512, truncation=True)

    # Generate summary ids
    summary_ids = model.generate(inputs, max_length=50, min_length=25, length_penalty=2.0, num_beams=4, early_stopping=True)

    # Decode the summary ids
    summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    return summary

def main():
    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Example list of questions to summarize
    questions_to_summarize = [
        "What is the role of a project manager?",
        "How does a project manager ensure project success?",
        "What are the key responsibilities of project management?"
    ]

    # Summarize the questions
    summary = summarize_questions(questions_to_summarize)
    print(f"Summary: {summary}")

if __name__ == "__main__":
    main()



import os

def join_files(part_files_folder, output_file_path, base_filename="model.safetensors"):
    """
    Joins split files from a specified folder back into a single file.
    Args:
        part_files_folder (str): The path to the folder containing the part files.
        output_file_path (str): The path to save the joined file.
        base_filename (str): The base name of the part files (default is "model.safetensors").
    """
    part_num = 0
    with open(output_file_path, 'wb') as output_file:
        while True:
            part_file_name = os.path.join(part_files_folder, f"{base_filename}.part{part_num}")
            if not os.path.exists(part_file_name):
                break  # Stop when no more part files are found
            with open(part_file_name, 'rb') as part_file:
                output_file.write(part_file.read())
            print(f"Joined {part_file_name}")``
            part_num += 1

    print(f"All parts joined into {output_file_path}")

# Usage example:
part_files_folder = "path/to/your/part/files/folder"  # Folder where part files are located
output_file_path = "path/to/output/model_joined.safetensors"  # Path to save the joined file
join_files(part_files_folder, output_file_path, base_filename="model.safetensors")


from transformers import pipeline

def summarize_questions(questions):
    summarizer = pipeline("summarization")
    combined_text = " ".join(questions)
    summary = summarizer(combined_text, max_length=50, min_length=25, do_sample=False)
    return summary[0]['summary_text']


def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    seen_questions = set()

    for i in range(similarity_matrix.shape[0]):
        if i not in seen_questions:
            group = [i]
            seen_questions.add(i)

            for j in range(i + 1, similarity_matrix.shape[1]):
                if similarity_matrix[i][j] > threshold:
                    group.append(j)
                    seen_questions.add(j)

            similar_groups.append(group)

    return similar_groups


from sklearn.decomposition import LatentDirichletAllocation
from sklearn.feature_extraction.text import CountVectorizer

def extract_keywords_lda(questions):
    vectorizer = CountVectorizer(stop_words='english')
    doc_term_matrix = vectorizer.fit_transform(questions)

    lda = LatentDirichletAllocation(n_components=1, random_state=42)
    lda.fit(doc_term_matrix)

    # Get the words in the topic
    feature_names = vectorizer.get_feature_names_out()
    keywords = [feature_names[i] for i in lda.components_[0].argsort()[-3:]]  # Top 3 keywords
    return " | ".join(keywords)


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np
from collections import Counter
import re

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    visited = set()

    for i in range(similarity_matrix.shape[0]):
        if i in visited:
            continue
        group = [i]
        visited.add(i)

        for j in range(i + 1, similarity_matrix.shape[0]):
            if similarity_matrix[i, j] > threshold:
                group.append(j)
                visited.add(j)

        similar_groups.append(group)

    return similar_groups

def extract_keywords(questions):
    # Combine all questions in the group into a single string
    combined_text = " ".join(questions)
    # Use regex to remove punctuation and split into words
    words = re.findall(r'\w+', combined_text.lower())
    # Count the frequency of each word
    word_counts = Counter(words)
    # Extract the most common words as keywords
    keywords = word_counts.most_common(3)  # Get top 3 keywords
    # Return a simple group name based on keywords
    return " | ".join(word for word, count in keywords)

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar groups based on threshold
    threshold = 0.8
    similar_groups = find_similar_groups(similarity_matrix, threshold)

    # Display similar question groups with names
    for group in similar_groups:
        questions_in_group = [df_unanswered.iloc[i]['Question'] for i in group]
        group_name = extract_keywords(questions_in_group)
        print(f"Group Name: {group_name}")
        for question in questions_in_group:
            print(f"- {question}")
        print()  # Blank line for better readability

if __name__ == "__main__":
    main()


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    visited = set()
    
    for i in range(similarity_matrix.shape[0]):
        if i in visited:
            continue
        group = [i]
        visited.add(i)
        
        for j in range(i + 1, similarity_matrix.shape[0]):
            if similarity_matrix[i, j] > threshold:
                group.append(j)
                visited.add(j)
        
        similar_groups.append(group)
    
    return similar_groups

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar groups based on threshold
    threshold = 0.8
    similar_groups = find_similar_groups(similarity_matrix, threshold)

    # Display similar question groups
    for group in similar_groups:
        questions_in_group = [df_unanswered.iloc[i]['Question'] for i in group]
        print("Similar Questions Group:")
        for question in questions_in_group:
            print(f"- {question}")
        print()  # Blank line for better readability

if __name__ == "__main__":
    main()

sentence1,sentence2,label
"How do I install Jenkins on Ubuntu?", "What are the steps to set up Jenkins on an Ubuntu server?",1
"How can I create a new repository in Bitbucket?", "What's the process for initializing a repository on Bitbucket?",1
"How to configure Sonarqube for code quality analysis?", "What settings should I adjust in Sonarqube to evaluate code quality?",1
"How do I use Ansible to automate server deployments?", "What are the Ansible commands for automating the deployment of servers?",1
"How to integrate Confluence with Jira?", "What is the method to link Confluence pages to Jira tickets?",1
"How do I troubleshoot Jenkins build failures?", "What steps should I take to fix failed builds in Jenkins?",1
"How to set up Bitbucket pipelines for CI/CD?", "What is the procedure to configure CI/CD pipelines in Bitbucket?",1
"How can Sonarqube help in maintaining code standards?", "In what ways does Sonarqube assist with enforcing coding standards?",1
"How to manage playbooks in Ansible?", "What is the best practice for organizing Ansible playbooks?",1
"How do I create Jira dashboards for project tracking?", "What's the way to set up dashboards in Jira for monitoring projects?",1
"How to secure Jenkins with authentication?", "What methods can I use to add authentication to Jenkins?",1
"How can I merge branches in Bitbucket?", "What's the process for merging different branches in Bitbucket repositories?",1
"How to analyze code smells using Sonarqube?", "What steps do I follow to detect code smells with Sonarqube?",1
"How do I deploy applications using Ansible?", "What are the commands to deploy apps through Ansible?",1
"How to collaborate using Confluence and Jira together?", "What is the way to use Confluence and Jira for team collaboration?",1
"How to resolve Jenkins plugin compatibility issues?", "What should I do if Jenkins plugins are not compatible with each other?",1
"How to set up access controls in Bitbucket?", "What's the method to configure user permissions in Bitbucket?",1
"How can Sonarqube integrate with Jenkins?", "What is the process to connect Sonarqube with Jenkins for continuous integration?",1
"How to write Ansible roles for infrastructure management?", "What steps are involved in creating Ansible roles for managing infrastructure?",1
"How to track issues in Jira using Confluence?", "What is the way to monitor Jira issues through Confluence pages?",1
"How do I update Jenkins to the latest version?", "What's the procedure for upgrading Jenkins to its newest release?",1
"How can I clone a Bitbucket repository locally?", "What commands do I use to clone a repository from Bitbucket to my machine?",1
"How to interpret Sonarqube analysis reports?", "What should I understand from the reports generated by Sonarqube?",1
"How to configure Ansible inventory files?", "What is the method to set up inventory files in Ansible?",1
"How do I create a Confluence space for my team?", "What's the process to establish a new space in Confluence for team collaboration?",1
"How to assign tasks in Jira projects?", "What steps do I follow to allocate tasks within Jira project boards?",1
"How to back up Jenkins configurations?", "What's the way to create backups of Jenkins setup and configurations?",1
"How can I enable branch permissions in Bitbucket?", "What is the method to set branch access controls in Bitbucket?",1
"How to set quality gates in Sonarqube?", "What steps do I take to establish quality gates within Sonarqube?",1
"How do I use Ansible to manage Docker containers?", "What are the Ansible playbooks for handling Docker container deployments?",1
"How to link Jira issues to Confluence documents?", "What's the procedure to associate Jira tickets with Confluence pages?",1


from sentence_transformers import SentenceTransformer, InputExample, losses
from torch.utils.data import DataLoader
import pandas as pd
import torch
import logging

# Enable logging
logging.basicConfig(format='%(asctime)s - %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S',
                    level=logging.INFO)

def main():
    # Step 1: Load the dataset
    df = pd.read_csv('data/similar_questions.csv')

    # Step 2: Prepare the data
    train_examples = []
    for index, row in df.iterrows():
        train_examples.append(
            InputExample(texts=[row['sentence1'], row['sentence2']], label=row['label'])
        )

    # Step 3: Load the pre-trained SBERT model from local directory
    model_path = 'models/all-MiniLM-L6-v2'  # Update this path accordingly
    model = SentenceTransformer(model_path)

    # Step 4: Define the training objective
    # For regression (similarity scores)
    train_loss = losses.CosineSimilarityLoss(model)

    # For classification (binary labels), uncomment the following:
    # train_loss = losses.SoftmaxLoss(model=model, sentence_embedding_dimension=model.get_sentence_embedding_dimension(), num_labels=2)

    # Step 5: Create a DataLoader
    train_dataloader = DataLoader(train_examples, shuffle=True, batch_size=16)

    # Step 6: Fine-tune the model
    num_epochs = 4
    warmup_steps = int(len(train_dataloader) * num_epochs * 0.1)  # 10% of train data

    model.fit(
        train_objectives=[(train_dataloader, train_loss)],
        epochs=num_epochs,
        warmup_steps=warmup_steps,
        device=torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    )

    # Step 7: Save the fine-tuned model
    model.save('models/fine-tuned-sbert')

if __name__ == "__main__":
    main()


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_pairs(similarity_matrix, threshold=0.8):
    similar_pairs = np.argwhere(similarity_matrix > threshold)
    # Remove self-pairs and duplicate pairs
    similar_pairs = [(i, j) for i, j in similar_pairs if i < j]
    return similar_pairs

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar pairs based on threshold
    threshold = 0.8
    similar_pairs = find_similar_pairs(similarity_matrix, threshold)

    # Display similar question pairs
    for i, j in similar_pairs:
        print(f"Question {i+1} and Question {j+1} are similar:")
        print(f"Q{i+1}: {df_unanswered.iloc[i]['Question']}")
        print(f"Q{j+1}: {df_unanswered.iloc[j]['Question']}\n")

if __name__ == "__main__":
    main()

import pandas as pd
import random

# Load all questions
df = pd.read_csv('similar_questions.csv')

# Separate similar and non-similar questions
similar_df = df[df['label'] == 1]
all_questions = df['sentence1'].tolist() + df['sentence2'].tolist()

# Generate negative samples by pairing questions from different tools
negative_samples = []
tools = ['Jenkins', 'Bitbucket', 'Sonarqube', 'Ansible', 'Confluence', 'Jira']

for _ in range(100):  # Adjust the number as needed
    q1 = random.choice(all_questions)
    q2 = random.choice(all_questions)

    # Ensure questions are from different tools
    if any(tool in q1 for tool in tools) and any(tool in q2 for tool in tools):
        tool_q1 = next((tool for tool in tools if tool in q1), None)
        tool_q2 = next((tool for tool in tools if tool in q2), None)
        if tool_q1 != tool_q2:
            negative_samples.append({'sentence1': q1, 'sentence2': q2, 'label': 0})

# Create DataFrame for negative samples
negative_df = pd.DataFrame(negative_samples)

# Combine with similar questions
final_df = pd.concat([similar_df, negative_df], ignore_index=True)

# Shuffle the dataset
final_df = final_df.sample(frac=1).reset_index(drop=True)

# Save to CSV
final_df.to_csv('similar_questions.csv', index=False)


import os
import xml.etree.ElementTree as ET
import shutil
from typing import List, Tuple, Dict

# Mapping of connector namespaces to their corresponding Maven groupId and artifactId
CONNECTOR_DEPENDENCY_MAP = {
    'http://www.mulesoft.org/schema/mule/http': ('org.mule.connectors', 'mule-http-connector'),
    'http://www.mulesoft.org/schema/mule/db': ('org.mule.connectors', 'mule-db-connector'),
    'http://www.mulesoft.org/schema/mule/file': ('org.mule.connectors', 'mule-file-connector'),
    'http://www.mulesoft.org/schema/mule/ftp': ('org.mule.connectors', 'mule-ftp-connector'),
    'http://www.mulesoft.org/schema/mule/jms': ('org.mule.connectors', 'mule-jms-connector'),
    'http://www.mulesoft.org/schema/mule/vm': ('org.mule.connectors', 'mule-vm-connector'),
    # Add more mappings as needed
}

def parse_domain_resources(domain_path: str) -> Tuple[Dict[str, List[ET.Element]], set]:
    resources = {
        'connectors': [],
        'global_configs': [],
        'error_handlers': [],
        'security_configs': [],
        'schedulers': [],
        'transformers': [],
        'spring_beans': [],
        'other': []
    }
    used_namespaces = set()

    config_path = os.path.join(domain_path, "src", "main", "mule", "mule-domain-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Collect used namespaces
    for key, value in root.attrib.items():
        if key.startswith('xmlns:'):
            used_namespaces.add(value)

    for child in root:
        if '}' in child.tag:
            namespace = child.tag.split('}')[0][1:]  # Extract namespace
            used_namespaces.add(namespace)
            tag = child.tag.split('}')[1]
            if any(x in tag for x in ['config', 'configuration']):
                resources['connectors'].append(child)
            elif tag == 'global-property':
                resources['global_configs'].append(child)
            elif tag == 'error-handler':
                resources['error_handlers'].append(child)
            elif 'security' in tag or 'oauth' in tag:
                resources['security_configs'].append(child)
            elif 'scheduler' in tag:
                resources['schedulers'].append(child)
            elif 'transformer' in tag:
                resources['transformers'].append(child)
            elif tag == 'beans':
                resources['spring_beans'].append(child)
            else:
                resources['other'].append(child)

    return resources, used_namespaces

def update_project_config(project_path: str, resources: Dict[str, List[ET.Element]], used_namespaces: set):
    config_path = os.path.join(project_path, "src", "main", "mule", "mule-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Add all resources to the project config
    for resource_list in resources.values():
        for resource in resource_list:
            root.append(resource)

    # Update namespaces
    for namespace in used_namespaces:
        for prefix, uri in root.attrib.items():
            if uri == namespace:
                break
        else:
            # If namespace not found, add it with a generated prefix
            i = 1
            while f'xmlns:ns{i}' in root.attrib:
                i += 1
            root.set(f'xmlns:ns{i}', namespace)

    tree.write(config_path, encoding="UTF-8", xml_declaration=True)

def update_project_pom(project_path: str, domain_path: str, used_namespaces: set):
    domain_pom_path = os.path.join(domain_path, "pom.xml")
    project_pom_path = os.path.join(project_path, "pom.xml")

    domain_tree = ET.parse(domain_pom_path)
    domain_root = domain_tree.getroot()

    project_tree = ET.parse(project_pom_path)
    project_root = project_tree.getroot()

    # Transfer dependencies
    domain_deps = domain_root.find("./{*}dependencies")
    if domain_deps is not None:
        project_deps = project_root.find("./{*}dependencies")
        if project_deps is None:
            project_deps = ET.SubElement(project_root, "dependencies")

        for dep in domain_deps:
            if dep.find("./{*}classifier") is None or dep.find("./{*}classifier").text != "mule-domain":
                project_deps.append(dep)

    # Add connector dependencies based on used namespaces
    for namespace in used_namespaces:
        if namespace in CONNECTOR_DEPENDENCY_MAP:
            group_id, artifact_id = CONNECTOR_DEPENDENCY_MAP[namespace]
            new_dep = ET.SubElement(project_deps, "dependency")
            ET.SubElement(new_dep, "groupId").text = group_id
            ET.SubElement(new_dep, "artifactId").text = artifact_id
            # You might want to specify a version or use a property for versioning
            # ET.SubElement(new_dep, "version").text = "${mule.version}"

    # Transfer properties
    domain_props = domain_root.find("./{*}properties")
    if domain_props is not None:
        project_props = project_root.find("./{*}properties")
        if project_props is None:
            project_props = ET.SubElement(project_root, "properties")

        for prop in domain_props:
            if not project_props.find(f".//{prop.tag}"):
                project_props.append(prop)

    # Remove domain dependency
    for dep in project_root.findall(".//{*}dependency"):
        artifact_id = dep.find("./{*}artifactId")
        classifier = dep.find("./{*}classifier")
        if (artifact_id is not None and artifact_id.text == "my-domain-project" and
            classifier is not None and classifier.text == "mule-domain"):
            project_deps.remove(dep)

    project_tree.write(project_pom_path, encoding="UTF-8", xml_declaration=True)

def migrate_project(domain_path: str, project_path: str):
    print(f"Migrating project: {os.path.basename(project_path)}")

    # Parse domain resources and collect used namespaces
    resources, used_namespaces = parse_domain_resources(domain_path)

    # Update project configuration
    update_project_config(project_path, resources, used_namespaces)

    # Update project pom
    update_project_pom(project_path, domain_path, used_namespaces)

    # Copy any additional resources
    domain_resources_path = os.path.join(domain_path, "src", "main", "resources")
    project_resources_path = os.path.join(project_path, "src", "main", "resources")
    if os.path.exists(domain_resources_path):
        for item in os.listdir(domain_resources_path):
            s = os.path.join(domain_resources_path, item)
            d = os.path.join(project_resources_path, item)
            if os.path.isfile(s):
                shutil.copy2(s, d)

    print(f"Migration completed for project: {os.path.basename(project_path)}")

def main():
    domain_path = "/path/to/domain/project"
    projects = [
        "/path/to/project1",
        "/path/to/project2",
        # Add more project paths as needed
    ]

    for project_path in projects:
        migrate_project(domain_path, project_path)

if __name__ == "__main__":
    main()


