# Importing pandas and recalculating the target number of cores

import pandas as pd

data = {
    'Server name': ['Server1', 'Server2', 'Server3', 'Server4', 'Server5', 'Server6', 'Server7', 'Server8'],
    'Total Cores': [12, 12, 12, 12, 16, 16, 16, 16],
    'March Utilization': [3.98, 2.98, 1.98, 10.98, 3.71, 4.98, 3.71, 16.07],
    'April Utilization': [4.03, 5.03, 8.03, 45.50, 3.06, 7.50, 3.06, 24.21],
    'May Utilization': [5.67, 8.67, 4.67, 3.67, 2.73, 3.67, 2.73, 23.67],
    'June Utilization': [3.98, 12.98, 11.98, 4.98, 11.53, 4.98, 11.53, 4.98],
    'July Utilization': [10.91, 12.91, 10.91, 2.91, 18.77, 2.91, 18.77, 2.91],
    'August Utilization': [69.1, 0.74, 1.74, 3.28, 27.10, 3.28, 27.10, 33.28]
}

#df = pd.read_excel("/path/to/your/excel/file.xlsx", sheet_name="Sheet1")

df = pd.DataFrame(data)

# Calculate monthly peak core utilization for each server
for month in ['March Utilization', 'April Utilization', 'May Utilization', 'June Utilization', 'July Utilization', 'August Utilization']:
    df[f'{month} Cores'] = df[month] * df['Total Cores']

# Aggregate monthly peaks
monthly_peaks = df[[f'{month} Cores' for month in ['March Utilization', 'April Utilization', 'May Utilization', 'June Utilization', 'July Utilization', 'August Utilization']]].sum()

# Determine overall peak utilization
overall_peak = monthly_peaks.max()

# Consider 20% headroom
headroom = 0.20 * overall_peak

# Calculate total target cores
target_cores = overall_peak + headroom

target_cores

# Compute monthly peaks for each server
monthly_peaks_df = df[[f'{month} Cores' for month in ['March Utilization', 'April Utilization', 'May Utilization', 'June Utilization', 'July Utilization', 'August Utilization']]]

# Compute the median of peaks for each month
median_peaks = monthly_peaks_df.median()

# Anomaly detection using Interquartile Range (IQR)
Q1 = median_peaks.quantile(0.25)
Q3 = median_peaks.quantile(0.75)
IQR = Q3 - Q1

# Define bounds for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out outliers
adjusted_peaks = median_peaks[(median_peaks >= lower_bound) & (median_peaks <= upper_bound)]

# Compute the adjusted peak and add 20% headroom
adjusted_peak = adjusted_peaks.max()
headroom = 0.20 * adjusted_peak
target_cores_adjusted = adjusted_peak + headroom

target_cores_adjusted

Container escapes. A container escape is a vulnerability that allows an attacker to break out of a container and gain access to the host OS or other containers. Container escapes can be caused by misconfigurations, software bugs, or malicious code.
Shared kernel vulnerabilities. If a vulnerability is found in the host OS kernel, it could potentially be exploited by any container running on that host.
Privileged containers. Containers can be granted privileged access to the host OS and other containers. This can make them more attractive targets for attackers.
Image vulnerabilities. Container images are often built from open source software packages. If a vulnerability is found in one of these packages, it could be present in all container images built from that package.


<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.oracle.database.jdbc</groupId>
        <artifactId>ojdbc8</artifactId>
        <version>19.8.0.0</version>
    </dependency>
</dependencies>



spring.datasource.url=jdbc:oracle:thin:@<hostname>:<port>:<SID>
spring.datasource.username=<username>
spring.datasource.password=<password>
spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect


@Bean
public DataSource dataSource() {
    return DataSourceBuilder.create()
            .url("jdbc:oracle:thin:@<hostname>:<port>:<SID>")
            .username("<username>")
            .password("<password>")
            .driverClassName("oracle.jdbc.OracleDriver")
            .build();
}

        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <version>9.2.1.jre11</version>
        </dependency>

Minimizing application startup time is essential for effective containerization, especially in cloud-native environments. Key factors affecting startup time include monolithic architecture, costly initialization operations, local cache loading, and external system dependencies. Remediation strategies include transitioning to a microservices architecture for parallelized startup, employing lazy loading and asynchronous initialization to defer or parallelize costly operations, utilizing external cache backing services to offload cache initialization, and implementing health checks and timeouts for external systems. Additionally, modularizing the codebase, optimizing configuration management, and ensuring adequate hardware resources can further reduce startup time. Keeping libraries updated, reducing excessive logging, running database migrations outside the startup process, profiling the boot sequence, and disabling unnecessary auto-configuration are also vital steps towards optimizing startup time, making applications more suited for rapid scaling and failover in containerized deployments.


In transitioning from a legacy setup to a containerized environment, a core challenge lies in managing application configurations, traditionally encapsulated within various config files. The modern container paradigm necessitates the externalization of these configurations as environment variables or via centralized services. This externalization is crucial for several reasons: it facilitates a clean separation between application code and configuration, promotes environment consistency across development, testing, and production stages, simplifies the scaling process of applications, and enhances security by segregating sensitive configuration details from the codebase. Moreover, it aligns with modern deployment methodologies and cloud-native principles, ensuring the system is easily configurable, manageable, and scalable in a dynamic containerized setup. Identifying a robust, scalable solution to migrate, manage, and secure these configurations in the new setup is the central issue demanding attention. The recipe provided will focus how to externalize the configuration files to environment variable with support for multiple environements(Dev/QA/Prod).  This recipe will also cover on how to migrate secrets (ex : DB passwords, API Token etc..) from configuration to Vault Services
