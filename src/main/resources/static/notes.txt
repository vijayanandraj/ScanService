import os
import platform
import subprocess
import sys

def set_env_variable_windows(var, value):
    try:
        # Use setx to set the environment variable for the current user
        subprocess.run(['setx', var, value], check=True)
        print(f"Set {var}={value} permanently for the user on Windows.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to set {var} on Windows: {e}")

def set_env_variable_linux(var, value):
    bashrc_path = os.path.expanduser("~/.bashrc")
    export_line = f'\nexport {var}="{value}"\n'
    
    # Check if the variable already exists in .bashrc
    if os.path.exists(bashrc_path):
        with open(bashrc_path, 'r') as file:
            lines = file.readlines()
        
        for i, line in enumerate(lines):
            if line.startswith(f'export {var}='):
                lines[i] = export_line
                break
        else:
            lines.append(export_line)
    else:
        lines = [export_line]
    
    # Append or modify the .bashrc file
    with open(bashrc_path, 'w') as file:
        file.writelines(lines)
    
    print(f"Set {var}={value} permanently in {bashrc_path}.")
    print("Run `source ~/.bashrc` or restart your terminal to apply changes.")

def main():
    if len(sys.argv) < 2:
        print("Usage: python set_env_vars.py VAR1=VALUE1 VAR2=VALUE2 ...")
        sys.exit(1)
    
    # Parse key=value pairs from command-line arguments
    env_vars = {}
    for arg in sys.argv[1:]:
        if '=' in arg:
            key, value = arg.split('=', 1)
            env_vars[key] = value
        else:
            print(f"Invalid argument '{arg}'. Expected format VAR=VALUE.")
            sys.exit(1)
    
    current_os = platform.system()
    
    if current_os == "Windows":
        for var, value in env_vars.items():
            set_env_variable_windows(var, value)
    elif current_os in ["Linux", "Darwin"]:  # Darwin for macOS
        for var, value in env_vars.items():
            set_env_variable_linux(var, value)
    else:
        print(f"Unsupported OS: {current_os}")
        sys.exit(1)

if __name__ == "__main__":
    main()

from jira import JIRA
import pandas as pd
import os
from datetime import datetime
import concurrent.futures
from typing import Dict, List, Any
import time
from tqdm import tqdm

def connect_to_jira(jira_server: str, username: str, api_token: str) -> JIRA:
    """
    Connect to JIRA instance using basic authentication
    """
    try:
        jira = JIRA(server=jira_server, basic_auth=(username, api_token))
        return jira
    except Exception as e:
        print(f"Failed to connect to JIRA: {str(e)}")
        return None

def format_comments(comments: List[Any]) -> str:
    """
    Format comments with delimiter and user information
    Comments are sorted chronologically with oldest first
    """
    if not comments:
        return ""

    formatted_comments = []
    delimiter = "================\n"

    # Sort comments by created date
    sorted_comments = sorted(comments, key=lambda x: x.created)

    for comment in sorted_comments:
        comment_text = f"Author: {comment.author.displayName}\n"
        comment_text += f"Date: {comment.created}\n"
        comment_text += f"Comment:\n{comment.body}\n"
        formatted_comments.append(comment_text)

    return delimiter.join(formatted_comments)

def process_single_ticket(args: tuple) -> Dict[str, str]:
    """
    Process a single JIRA ticket
    Returns a dictionary with ticket data
    """
    ticket_id, jira_server, username, api_token = args

    try:
        # Create a new JIRA connection for each thread
        jira = connect_to_jira(jira_server, username, api_token)
        if not jira:
            return {
                'ticket_id': ticket_id,
                'summary': 'ERROR - Connection Failed',
                'description': 'ERROR - Connection Failed',
                'comments': 'ERROR - Connection Failed'
            }

        issue = jira.issue(ticket_id)

        # Get comments
        comments = jira.comments(issue)
        formatted_comments = format_comments(comments)

        return {
            'ticket_id': ticket_id,
            'summary': issue.fields.summary,
            'description': issue.fields.description or "",
            'comments': formatted_comments
        }

    except Exception as e:
        return {
            'ticket_id': ticket_id,
            'summary': f'ERROR: {str(e)}',
            'description': f'ERROR: {str(e)}',
            'comments': f'ERROR: {str(e)}'
        }

def process_jira_tickets(jira_server: str, username: str, api_token: str,
                        input_csv: str, output_excel: str, max_workers: int = 10):
    """
    Main function to process JIRA tickets in parallel and create Excel output
    """
    try:
        # Read ticket IDs from CSV
        df = pd.read_csv(input_csv)
        ticket_column = df.columns[0]  # Assume first column contains ticket IDs
        ticket_ids = df[ticket_column].tolist()

        # Prepare arguments for parallel processing
        args_list = [(ticket_id, jira_server, username, api_token)
                    for ticket_id in ticket_ids]

        results = []

        # Process tickets in parallel with progress bar
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = [executor.submit(process_single_ticket, args)
                      for args in args_list]

            # Show progress bar
            for future in tqdm(concurrent.futures.as_completed(futures),
                             total=len(ticket_ids),
                             desc="Processing tickets"):
                results.append(future.result())

        # Sort results by original ticket order
        ticket_id_to_index = {tid: idx for idx, tid in enumerate(ticket_ids)}
        results.sort(key=lambda x: ticket_id_to_index[x['ticket_id']])

        # Create output DataFrame
        output_df = pd.DataFrame({
            'Ticket ID': [r['ticket_id'] for r in results],
            'Summary': [r['summary'] for r in results],
            'Description': [r['description'] for r in results],
            'Comments': [r['comments'] for r in results]
        })

        # Write to Excel
        output_df.to_excel(output_excel, index=False, engine='openpyxl')
        print(f"\nSuccessfully created Excel file: {output_excel}")

    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    # Configuration
    JIRA_SERVER = "https://your-jira-instance.com"
    USERNAME = "your-username"
    API_TOKEN = "your-api-token"

    # File paths
    INPUT_CSV = "jira_tickets.csv"
    OUTPUT_EXCEL = f"jira_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"

    # Number of parallel workers
    MAX_WORKERS = 10  # Adjust based on your system capabilities and JIRA rate limits

    # Run the process
    start_time = time.time()
    process_jira_tickets(
        JIRA_SERVER,
        USERNAME,
        API_TOKEN,
        INPUT_CSV,
        OUTPUT_EXCEL,
        MAX_WORKERS
    )
    end_time = time.time()

    print(f"Total processing time: {end_time - start_time:.2f} seconds")


GIVEN

The current source code contains hard-coded secrets (such as API keys, passwords) and a hard-coded nbkid identifier.
These hard-coded values are embedded directly within the application's codebase, posing security risks and hindering maintainability.
WHEN

A developer refactors the source code to remove all hard-coded secrets and the nbkid.
The secrets and nbkid are moved to secure external configuration sources (e.g., environment variables, configuration files, secret management services).
THEN

The application retrieves secrets and the nbkid from the external configuration sources at runtime.
Security is enhanced by preventing sensitive information from being exposed in the codebase.
Maintainability is improved, allowing for easier updates and management of secrets and identifiers without modifying the source code.
Compliance with security best practices and organizational policies is achieved.

def filter_email_addresses(to_list=None, from_addr=None, cc_list=None, exclude_patterns=None, exact_emails=None):
    if exclude_patterns is None:
        exclude_patterns = [r'\.deleted@']  # Default pattern changed to match BOFA .deleted@ format

    if exact_emails is None:
        exact_emails = []

    def should_exclude(email):
        if not email:
            return False
        if email.lower() in (e.lower() for e in exact_emails):
            return True
        for pattern in exclude_patterns:
            try:
                if re.search(pattern, email, re.IGNORECASE):
                    return True
            except re.error:
                if pattern.lower() in email.lower():
                    return True
        return False

    filtered_to = []
    if to_list:
        filtered_to = [email for email in to_list if not should_exclude(email)]

    filtered_from = from_addr
    if from_addr and should_exclude(from_addr):
        filtered_from = None

    filtered_cc = []
    if cc_list:
        filtered_cc = [email for email in cc_list if not should_exclude(email)]

    return filtered_to, filtered_from, filtered_cc


from jira import JIRA
import pandas as pd
import os
from datetime import datetime

def connect_to_jira(jira_server, username, api_token):
    """
    Connect to JIRA instance using basic authentication
    """
    try:
        jira = JIRA(server=jira_server, basic_auth=(username, api_token))
        return jira
    except Exception as e:
        print(f"Failed to connect to JIRA: {str(e)}")
        return None

def format_comments(comments):
    """
    Format comments with delimiter and user information
    Comments are sorted chronologically with oldest first
    """
    if not comments:
        return ""

    formatted_comments = []
    delimiter = "================\n"

    # Sort comments by created date
    sorted_comments = sorted(comments, key=lambda x: x.created)

    for comment in sorted_comments:
        comment_text = f"Author: {comment.author.displayName}\n"
        comment_text += f"Date: {comment.created}\n"
        comment_text += f"Comment:\n{comment.body}\n"
        formatted_comments.append(comment_text)

    return delimiter.join(formatted_comments)

def process_jira_tickets(jira_server, username, api_token, input_csv, output_excel):
    """
    Main function to process JIRA tickets and create Excel output
    """
    # Connect to JIRA
    jira = connect_to_jira(jira_server, username, api_token)
    if not jira:
        return

    try:
        # Read ticket IDs from CSV
        df = pd.read_csv(input_csv)
        ticket_column = df.columns[0]  # Assume first column contains ticket IDs

        # Initialize lists to store data
        summaries = []
        descriptions = []
        all_comments = []

        # Process each ticket
        for ticket_id in df[ticket_column]:
            try:
                issue = jira.issue(ticket_id)

                # Get summary
                summaries.append(issue.fields.summary)

                # Get description
                descriptions.append(issue.fields.description or "")

                # Get comments
                comments = jira.comments(issue)
                formatted_comments = format_comments(comments)
                all_comments.append(formatted_comments)

                print(f"Successfully processed ticket: {ticket_id}")

            except Exception as e:
                print(f"Error processing ticket {ticket_id}: {str(e)}")
                summaries.append("ERROR")
                descriptions.append("ERROR")
                all_comments.append("ERROR")

        # Create output DataFrame
        output_df = pd.DataFrame({
            'Summary': summaries,
            'Description': descriptions,
            'Comments': all_comments
        })

        # Write to Excel
        output_df.to_excel(output_excel, index=False, engine='openpyxl')
        print(f"Successfully created Excel file: {output_excel}")

    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    # Configuration
    JIRA_SERVER = "https://your-jira-instance.com"
    USERNAME = "your-username"
    API_TOKEN = "your-api-token"

    # File paths
    INPUT_CSV = "jira_tickets.csv"
    OUTPUT_EXCEL = f"jira_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"

    # Run the process
    process_jira_tickets(JIRA_SERVER, USERNAME, API_TOKEN, INPUT_CSV, OUTPUT_EXCEL)

# location_inspector.py
import site
import sys
from pathlib import Path
import os

def print_package_locations():
    """Print all relevant Python package installation locations"""

    print("\n=== Python Environment Information ===")
    print(f"Python Version: {sys.version}")
    print(f"Python Executable: {sys.executable}")

    print("\n=== Site Packages Locations ===")
    # Get all site-packages directories
    for path in site.getsitepackages():
        print(f"Site packages: {path}")
        print(f"edt_service would be installed at: {Path(path) / 'edt_service'}")

    print("\n=== Virtual Environment Status ===")
    is_venv = hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
    print(f"Running in virtual environment: {is_venv}")
    if is_venv:
        print(f"Virtual environment path: {sys.prefix}")
        venv_site_packages = Path(sys.prefix) / 'lib' / f'python{sys.version_info.major}.{sys.version_info.minor}' / 'site-packages'
        print(f"Venv site-packages: {venv_site_packages}")
        print(f"edt_service would be installed at: {venv_site_packages / 'edt_service'}")

if __name__ == "__main__":
    print_package_locations()

Ah, great question! Let me explain the architecture of VS Code with Dev Containers:
VS Code's architecture with Dev Containers works in a client-server model:

Client Side (Host Machine):


VS Code UI/Editor
Extension Host Process for UI-related extensions
Your source code files


Container Side (Dev Container):


Development tools (Java, Maven, etc.)
Language servers
Development-specific extensions
Build/run environment

When you specify extensions in devcontainer.json, they are installed in the container because:

Language Services:


Extensions like vscjava.vscode-java-pack need to run where the Java compiler and tools are
The Java Language Server runs inside the container to access the Java runtime
This ensures code completion, diagnostics, and debugging work with the container's Java version


Tool Integration:


Maven extension needs to interact with Maven installed in the container
Spring Boot extensions need to access Spring tools in the container
These extensions communicate with VS Code UI via VS Code's remote protocol

[Your Machine]                        [Dev Container]
VS Code UI  <--Remote Protocol-->     Java Language Server
Editor      <-------------------->    Maven
Extensions UI                         Spring Boot Tools
                                     Development Extensions

An example to illustrate:

When you type Java code, the keystroke happens in VS Code on your machine
The code is sent to the Java Language Server running in the container
The server analyzes the code using the container's Java installation
Results (completions, errors) are sent back to VS Code UI

If we didn't install these extensions in the container:

Code completion wouldn't work
Build tools wouldn't be accessible
Debugging wouldn't function
Language features would be missing


DevContainers (Development Containers) are standardized, containerized environments that encapsulate all necessary tools, dependencies, and configurations required for software development. They ensure that every developer works within an identical setup, regardless of their local machine’s operating system or hardware.

How DevContainers Work:

Configuration Specifications:

devcontainer.json: Defines environment settings, extensions, and tools needed for the project.
Dockerfile: Specifies the step-by-step instructions to build the container image, including installing dependencies and configuring the environment.
Containerization Platform:

Docker or Podman: Creates and manages the isolated containers based on the provided configurations, ensuring consistency and isolation from the host system.
IDE Integration:

Visual Studio Code (VSCode): Automatically builds and launches the DevContainer when a project is opened, providing a seamless development experience within the standardized environment.
DevContainer Specifications:

Standardization: Follows a defined specification to ensure compatibility across different tools and platforms.
Version Control: Configuration files are stored alongside the project’s source code, enabling versioning and easy reproducibility for all team members.

Introduction
In our rapidly evolving technological landscape, maintaining a high level of developer productivity and ensuring consistency across diverse projects is paramount. Currently, our organization supports a vast community of over 30,000 developers working across multiple ecosystems, including Java, .NET, Python, NodeJS, Scala, Go, and Rust. However, the traditional approach to setting up development environments is proving to be a significant bottleneck, impeding our ability to deliver high-quality software efficiently.

Current Challenges
Prolonged Onboarding Time

Issue: Developers spend an average of 5+ days configuring their local environments before making their first meaningful code commit.
Impact: Delays in project initiation, reduced productivity, and increased time-to-market for new features and products.
Inconsistent Development Environments

Issue: Variability in individual setups leads to the notorious "it works on my machine" problem.
Impact: Increased bug rates, integration issues, and extended debugging cycles, ultimately affecting software quality and reliability.
High Maintenance Overhead

Issue: Manual installation and updates of dependencies (e.g., app servers, language runtimes, build tools) across diverse ecosystems are time-consuming and error-prone.
Impact: Significant allocation of developer time to environment maintenance rather than productive coding and innovation.
Inefficient Collaboration

Issue: Disparate environments hinder seamless teamwork and knowledge sharing.
Impact: Fragmented development efforts, duplicated work, and slower project progression.

 Proposed Solution

1. Choice of Development Environments:

Cloud-Based IDEs:
Options: GitHub Codespaces, RedHat Devspaces
Advantages: Seamless cloud integration, scalability, and support for modern development workflows.
Native IDEs with DevContainers:
Tools: VSCode with DevContainers extension, PodMan Desktop, Artifactory for image repositories
Advantages: Familiar native environments, flexibility, and support for a wide range of IDEs.
2. Phased Implementation Approach:

Phase 1: Adopt DevContainers for Native IDE Users

Actions:
Standardize on DevContainers to provide consistent, containerized environments for native IDEs (e.g., VSCode, JetBrains).
Deploy PodMan Desktop and Artifactory to manage and distribute container images.
Address Eclipse users by developing specialized DevContainer configurations and providing enhanced support.
Goals: Achieve immediate reduction in onboarding time, ensure environment consistency, and enhance developer productivity.
Phase 2: Integrate Cloud-Based IDEs

Actions:
Pilot RedHat Devspaces to offer cloud-based development environments that support the DevContainers specification.
Enable GitHub Codespaces for developers comfortable with cloud IDEs, ensuring compatibility with existing DevContainer setups.
Evaluate and expand cloud IDE usage based on Phase 1 outcomes and developer feedback.
Goals: Provide flexibility for Gen-Z developers and those preferring cloud solutions, while maintaining support for native IDE workflows.
3. Addressing Eclipse Ecosystem Challenges:

Strategies:
Develop tailored DevContainer configurations specific to Eclipse.
Provide comprehensive training and support to Eclipse users to facilitate the transition.
Collaborate with Eclipse plugin developers to enhance DevContainer compatibility.

Infrastructure Components:
PodMan Desktop: Manage containerized environments locally with enhanced security.
Artifactory: Central repository for storing and versioning container images.
VSCode Extensions: Facilitate seamless integration with DevContainers for native IDE users.
WSL + Hyper-V: Ensure compatibility and performance for Windows-based developers.

2. Strategic Benefits

Accelerated Time-to-Productivity:
Drastically reduce environment setup time, enabling developers to contribute code within hours.
Consistency and Quality:
Ensure uniform development environments, minimizing bugs and enhancing software reliability.
Scalability and Flexibility:
Support a large and diverse developer community with varied preferences and toolsets.
Cost Efficiency:
Lower maintenance overhead and reduce delays, translating to significant cost savings and better resource allocation.
Enhanced Developer Satisfaction:
Provide modern, flexible development workflows catering to both cloud-native and traditional developers, increasing overall satisfaction and retention.


Key Benefits
Accelerated Onboarding and Setup

Reduction in Setup Time: Developers can initialize their environments in minutes instead of days, enabling immediate contributions.
Consistency Across Teams: Uniform environments eliminate setup discrepancies, ensuring that all developers work within the same configurations.
Enhanced Productivity and Efficiency

Focus on Development: Minimizes time spent on environment configuration, allowing developers to concentrate on writing and optimizing code.
Streamlined Updates: Centralized management of dependencies ensures that updates and patches are propagated uniformly, reducing individual maintenance efforts.
Improved Collaboration and Code Quality

Standardized Environments: Facilitates smoother collaboration by ensuring that all team members are working within the same setup.
Reduced Integration Issues: Consistent environments lower the incidence of environment-specific bugs, enhancing overall software quality.
Scalability and Flexibility

Support for Multiple Ecosystems: Easily accommodates various technology stacks (Java, .NET, Python, NodeJS, Scala, Go, Rust) through tailored DevContainer configurations.
Adaptable Infrastructure: Utilizes robust tools like PodMan and Artifactory to manage and scale containerized environments efficiently.
Cost Efficiency

Reduced Downtime: Faster setup times translate to higher utilization of developer resources and faster project turnaround.
Lower Maintenance Costs: Centralized environment management reduces the overhead associated with individual setups and troubleshooting.
Enhanced Security and Compliance

Controlled Environments: Containers encapsulate dependencies, minimizing the risk of security vulnerabilities and ensuring compliance with organizational standards.
Centralized Image Management: Artifactory serves as a secure repository for container images, enforcing access controls and versioning.



def extract_ticket_and_guid(email_body: str):
    """Extract Jira ticket ID and Thread ID from email body"""
    jira_pattern = r'https://jira3\.horizon\.bankofamerica\.com/browse/([A-Z]+-\d+)'
    guid_pattern = r'Thread ID: ([\w-]+)'

    jira_match = re.search(jira_pattern, email_body)
    guid_match = re.search(guid_pattern, email_body)

    jira_key = jira_match.group(1) if jira_match else None
    guid = guid_match.group(1) if guid_match else None

    return jira_key, guid

def find_email_thread_attachment(issue, guid):
    """Find the email thread attachment for given GUID"""
    for attachment in issue.fields.attachment:
        # Look for attachment with matching GUID in filename
        if f"email_thread_{guid}" in attachment.filename:
            return attachment.id
    return None

def update_email_thread_attachment(jira, issue_key, html_content, guid):
    """Update email thread attachment with new content"""
    issue = jira.issue(issue_key)

    # Find and delete old attachment
    old_attachment_id = find_email_thread_attachment(issue, guid)
    if old_attachment_id:
        jira.delete_attachment(old_attachment_id)

    # Add new attachment
    attachment_name = f"email_thread_{guid}.html"
    issue.add_attachment(
        attachment=html_content.encode('utf-8'),
        filename=attachment_name
    )

def create_response_email(mail, jira_key):
    """Create formatted email response with GUID"""
    guid = str(uuid.uuid4())

    response_body = (
        "Thank you for reaching out to Enterprise Developer Tooling.\n"  # First line
        "\n"  # Empty line
        "A ticket has been created for your reference:\n"  # Second line
        f"Jira Ticket: https://jira3.horizon.bankofamerica.com/browse/{jira_key}\n"  # Third line
        f"Thread ID: {guid}\n"  # Fourth line
        "\n"  # Empty line
        "Please feel free to comment on the ticket if you would like to leave feedback.\n"  # Fifth line
        "\n"  # Empty line
        "Best regards,\n"  # Sixth line
        "Enterprise Developer Tooling Team"  # Seventh line
    )

    # Create the email reply
    mail.create_reply_all(
        subject="Re: " + mail.subject,
        body=response_body
    )

    return guid

import uuid
import re

def generate_guid():
    """Generate a simple GUID"""
    return str(uuid.uuid4())

def add_guid_to_body(body, guid=None):
    """Add GUID to email body"""
    if guid is None:
        guid = generate_guid()
    guid_line = f"\n\nReference ID: {guid}\n"
    return body + guid_line

def extract_guid_from_body(body):
    """Extract GUID from email body if present"""
    pattern = r'Reference ID: ([\w-]+)'
    match = re.search(pattern, body)
    return match.group(1) if match else None

# Example usage:
original_body = """
Thank you for contacting IT Support.
Your ticket has been created and we will get back to you shortly.

Best regards,
IT Support Team
"""

# Adding GUID to email response
response_body = add_guid_to_body(original_body)
print("Email body with GUID:")
print(response_body)

# Later, when receiving a reply, extract the GUID
extracted_guid = extract_guid_from_body(response_body)
print(f"\nExtracted GUID: {extracted_guid}")

def setup_logging():
    log_folder = os.path.join(os.getcwd(), 'logs')

    if not os.path.exists(log_folder):
        os.makedirs(log_folder)

    log_file = os.path.join(log_folder, 'app.log')
    handler = RotatingFileHandler(log_file, maxBytes=10*1024*1024, backupCount=5)
    handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')
    handler.setFormatter(formatter)

    # Set up root logger
    logging.getLogger().setLevel(logging.INFO)
    logging.getLogger().addHandler(handler)

# File: setup.py
import json
from setuptools import setup, find_packages

# Read the contents of your README file
with open('README.md', 'r', encoding='utf-8') as f:
    long_description = f.read()

# Read the contents of your setup.json file
with open('setup.json', 'r') as f:
    config = json.load(f)

# Read the contents of your requirements.txt file
with open('requirements.txt', 'r') as f:
    requirements = f.read().splitlines()

setup(
    name=config['name'],
    version=config['version'],
    author=config.get('author', ''),
    author_email=config.get('author_email', ''),
    description=config.get('description', ''),
    long_description=long_description,
    long_description_content_type='text/markdown',
    url=config.get('url', ''),
    package_dir={"": "src"},
    packages=find_packages(where="src"),
    include_package_data=True,
    install_requires=requirements,
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
    entry_points={
        'console_scripts': [
            'edt-service=edt_service.app:main',
        ],
    },
)



# File: MANIFEST.in
include README.md
include requirements.txt
include setup.json
recursive-include src/edt_service/templates *
recursive-include src/edt_service/static *

import logging
from queue import Queue
from threading import Thread
from jira import JIRA
from tqdm import tqdm
import time

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='jira_cleanup.log',
    filemode='w'
)

# Add console handler if you want to see logs in console as well
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logging.getLogger('').addHandler(console)

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets
JQL_QUERY = '''
    project = DLAB
    AND issuekey >= DLAB-1651
    AND issuekey <= DLAB-12500
    AND summary ~ "Your specific text here"
'''

CANCELLED_RESOLUTION = "Cancelled"
CUSTOM_COMMENT = "This issue has been automatically closed as part of a cleanup process."

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except Exception as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except Exception as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def process_ticket(jira, issue):
    start_time = time.time()
    try:
        # Your existing process_ticket logic here
        # For example:
        jira.transition_issue(issue, 'Open')
        time.sleep(1)
        jira.transition_issue(issue, 'Close', fields={'resolution': {'name': CANCELLED_RESOLUTION}})
        jira.add_comment(issue, CUSTOM_COMMENT)
        # Detach from epic logic here

        end_time = time.time()
        processing_time = end_time - start_time
        logging.info(f"Processed ticket {issue.key} in {processing_time:.2f} seconds")
    except Exception as e:
        end_time = time.time()
        processing_time = end_time - start_time
        logging.error(f"Error processing ticket {issue.key} after {processing_time:.2f} seconds: {str(e)}")

def worker(jira, queue, progress_bar):
    while True:
        issue = queue.get()
        if issue is None:
            break
        try:
            process_ticket(jira, issue)
        except Exception as e:
            logging.error(f"Error in worker thread for ticket {issue.key}: {str(e)}")
        finally:
            queue.task_done()
            progress_bar.update(1)

def main():
    overall_start_time = time.time()

    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    queue = Queue()
    for issue in issues:
        queue.put(issue)

    num_threads = 10
    progress_bar = tqdm(total=len(issues), desc="Processing tickets")

    threads = []
    for _ in range(num_threads):
        thread = Thread(target=worker, args=(jira, queue, progress_bar))
        thread.start()
        threads.append(thread)

    queue.join()

    for _ in range(num_threads):
        queue.put(None)
    for thread in threads:
        thread.join()

    progress_bar.close()

    overall_end_time = time.time()
    total_time = overall_end_time - overall_start_time
    logging.info(f"Total processing time: {total_time:.2f} seconds")
    logging.info(f"Average time per ticket: {total_time / len(issues):.2f} seconds")

if __name__ == "__main__":
    main()

def add_comment(jira, issue):
    try:
        jira.add_comment(issue, CUSTOM_COMMENT)
        logging.info(f"Added comment to ticket {issue.key}")
        return True
    except JIRAError as e:
        logging.error(f"Failed to add comment to ticket {issue.key}: {str(e)}")
        return False


from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging
import time

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

# Define the resolution
CANCELLED_RESOLUTION = "Cancelled"

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def transition_to_open(jira, issue):
    try:
        jira.transition_issue(issue, 'Open')
        logging.info(f"Transitioned ticket {issue.key} to 'Open'")
        return True
    except JIRAError as e:
        logging.error(f"Failed to transition ticket {issue.key} to 'Open': {str(e)}")
        return False

def close_with_cancelled_resolution(jira, issue):
    try:
        jira.transition_issue(issue, 'Close', fields={'resolution': {'name': CANCELLED_RESOLUTION}})
        logging.info(f"Closed ticket {issue.key} with 'Cancelled' resolution")
        return True
    except JIRAError as e:
        logging.error(f"Failed to close ticket {issue.key} with 'Cancelled' resolution: {str(e)}")
        return False

def detach_from_epic(jira, issue):
    try:
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
            return True
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to detach ticket {issue.key} from EPIC: {str(e)}")
        return False

def process_ticket(jira, issue):
    # Step 1: Transition to "Open"
    if transition_to_open(jira, issue):
        time.sleep(1)  # Wait a short time to allow JIRA to process the transition

        # Step 2: Close with "Cancelled" resolution
        if close_with_cancelled_resolution(jira, issue):
            # Step 3: Detach from EPIC
            detach_from_epic(jira, issue)
        else:
            logging.warning(f"Could not close ticket {issue.key} with 'Cancelled' resolution")
    else:
        logging.warning(f"Could not open ticket {issue.key}. It may already be in the desired state.")

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        process_ticket(jira, issue)

if __name__ == "__main__":
    main()

from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging
import time

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def transition_issue(jira, issue, transition_name):
    try:
        transitions = jira.transitions(issue)
        transition_id = next((t['id'] for t in transitions if t['name'].lower() == transition_name.lower()), None)

        if transition_id:
            jira.transition_issue(issue, transition_id)
            logging.info(f"Transitioned ticket {issue.key} to '{transition_name}'")
            return True
        else:
            logging.warning(f"No '{transition_name}' transition found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to transition ticket {issue.key} to '{transition_name}': {str(e)}")
        return False

def detach_from_epic(jira, issue):
    try:
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
            return True
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")
            return False
    except JIRAError as e:
        logging.error(f"Failed to detach ticket {issue.key} from EPIC: {str(e)}")
        return False

def process_ticket(jira, issue):
    # Step 1: Transition to "Open"
    if transition_issue(jira, issue, "Open"):
        # Wait a short time to allow JIRA to process the first transition
        time.sleep(1)

        # Step 2: Transition to "Close"
        if transition_issue(jira, issue, "Close"):
            # Step 3: Detach from EPIC
            detach_from_epic(jira, issue)
        else:
            logging.warning(f"Could not close ticket {issue.key}")
    else:
        logging.warning(f"Could not open ticket {issue.key}. It may already be in the desired state.")

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        process_ticket(jira, issue)

if __name__ == "__main__":
    main()

from jira import JIRA
from jira.exceptions import JIRAError
from tqdm import tqdm
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Replace these with your actual JIRA instance details
JIRA_SERVER = "https://your-domain.atlassian.net"
JIRA_EMAIL = "your-email@example.com"
JIRA_API_TOKEN = "your-api-token"

# JQL query to find the tickets in the specified range
JQL_QUERY = 'project = DLAB AND issuekey >= DLAB-1651 AND issuekey <= DLAB-12500'

def connect_to_jira():
    try:
        return JIRA(server=JIRA_SERVER, basic_auth=(JIRA_EMAIL, JIRA_API_TOKEN))
    except JIRAError as e:
        logging.error(f"Failed to connect to JIRA: {str(e)}")
        raise

def get_tickets(jira):
    try:
        return jira.search_issues(JQL_QUERY, maxResults=False)
    except JIRAError as e:
        logging.error(f"Failed to fetch tickets: {str(e)}")
        raise

def cancel_and_detach_from_epic(jira, issue):
    try:
        # Find the 'Cancel' transition ID
        transitions = jira.transitions(issue)
        cancel_transition_id = next((t['id'] for t in transitions if t['name'].lower() == 'cancel'), None)

        if cancel_transition_id:
            jira.transition_issue(issue, cancel_transition_id)
            logging.info(f"Cancelled ticket {issue.key}")
        else:
            logging.warning(f"No 'Cancel' transition found for {issue.key}")

        # Detach from EPIC
        epic_link_field = next((f for f in jira.fields() if f['name'] == 'Epic Link'), None)
        if epic_link_field:
            issue.update(fields={epic_link_field['id']: None})
            logging.info(f"Detached ticket {issue.key} from EPIC")
        else:
            logging.warning(f"No 'Epic Link' field found for {issue.key}")

        return True
    except JIRAError as e:
        logging.error(f"Failed to cancel and detach ticket {issue.key}: {str(e)}")
        return False

def main():
    jira = connect_to_jira()
    issues = get_tickets(jira)

    logging.info(f"Found {len(issues)} tickets to process")

    for issue in tqdm(issues, desc="Processing tickets"):
        cancel_and_detach_from_epic(jira, issue)

if __name__ == "__main__":
    main()

import json
from setuptools import setup, find_packages

# Load setup configuration from setup.json
with open("setup.json", "r") as f:
    setup_config = json.load(f)

# Load dependencies from requirements.txt
with open("requirements.txt", "r") as f:
    install_requires = f.read().splitlines()

setup(
    name=setup_config["name"],
    version=setup_config["version"],
    description=setup_config["description"],
    author=setup_config["author"],
    author_email=setup_config["author_email"],
    url=setup_config["url"],
    packages=find_packages(include=["*"]),
    install_requires=install_requires,
    include_package_data=True,
    package_data={
        '': ['*.html'],  # Include HTML templates
    },
    entry_points={
        'console_scripts': [
            'run-flask-app=your_module.your_entry_file:main',  # Define the entry point
        ],
    },
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
)


[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "your-package-name"
version = "0.1.0"
description = "A description of your Python package"
authors = [
    {name = "Your Name", email = "your.email@example.com"},
]
dependencies = [
    "requests",
    "numpy",
]
readme = "README.md"
requires-python = ">=3.6"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]

[tool.setuptools.packages.find]
where = ["."]
include = ["*"]

[tool.setuptools.package-data]
"your_package_name" = ["*.html"]  # Include HTML templates, adjust this to your needs

[project.scripts]
run-flask-app = "your_package_name.your_entry_file:main"


from transformers import T5Tokenizer, T5ForConditionalGeneration

# Load the T5-small model and tokenizer
model_path = 'path/to/your/t5-small'  # Update this with the path to your downloaded model
tokenizer = T5Tokenizer.from_pretrained(model_path)
model = T5ForConditionalGeneration.from_pretrained(model_path)

def summarize_questions(questions):
    # Combine all questions into a single string
    input_text = " ".join(questions)
    input_text = "summarize: " + input_text  # Prefix for T5

    # Encode the input text
    inputs = tokenizer.encode(input_text, return_tensors='pt', max_length=512, truncation=True)

    # Generate summary ids
    summary_ids = model.generate(inputs, max_length=50, min_length=25, length_penalty=2.0, num_beams=4, early_stopping=True)

    # Decode the summary ids
    summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    return summary

def main():
    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Example list of questions to summarize
    questions_to_summarize = [
        "What is the role of a project manager?",
        "How does a project manager ensure project success?",
        "What are the key responsibilities of project management?"
    ]

    # Summarize the questions
    summary = summarize_questions(questions_to_summarize)
    print(f"Summary: {summary}")

if __name__ == "__main__":
    main()



import os

def join_files(part_files_folder, output_file_path, base_filename="model.safetensors"):
    """
    Joins split files from a specified folder back into a single file.
    Args:
        part_files_folder (str): The path to the folder containing the part files.
        output_file_path (str): The path to save the joined file.
        base_filename (str): The base name of the part files (default is "model.safetensors").
    """
    part_num = 0
    with open(output_file_path, 'wb') as output_file:
        while True:
            part_file_name = os.path.join(part_files_folder, f"{base_filename}.part{part_num}")
            if not os.path.exists(part_file_name):
                break  # Stop when no more part files are found
            with open(part_file_name, 'rb') as part_file:
                output_file.write(part_file.read())
            print(f"Joined {part_file_name}")``
            part_num += 1

    print(f"All parts joined into {output_file_path}")

# Usage example:
part_files_folder = "path/to/your/part/files/folder"  # Folder where part files are located
output_file_path = "path/to/output/model_joined.safetensors"  # Path to save the joined file
join_files(part_files_folder, output_file_path, base_filename="model.safetensors")


from transformers import pipeline

def summarize_questions(questions):
    summarizer = pipeline("summarization")
    combined_text = " ".join(questions)
    summary = summarizer(combined_text, max_length=50, min_length=25, do_sample=False)
    return summary[0]['summary_text']


def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    seen_questions = set()

    for i in range(similarity_matrix.shape[0]):
        if i not in seen_questions:
            group = [i]
            seen_questions.add(i)

            for j in range(i + 1, similarity_matrix.shape[1]):
                if similarity_matrix[i][j] > threshold:
                    group.append(j)
                    seen_questions.add(j)

            similar_groups.append(group)

    return similar_groups


from sklearn.decomposition import LatentDirichletAllocation
from sklearn.feature_extraction.text import CountVectorizer

def extract_keywords_lda(questions):
    vectorizer = CountVectorizer(stop_words='english')
    doc_term_matrix = vectorizer.fit_transform(questions)

    lda = LatentDirichletAllocation(n_components=1, random_state=42)
    lda.fit(doc_term_matrix)

    # Get the words in the topic
    feature_names = vectorizer.get_feature_names_out()
    keywords = [feature_names[i] for i in lda.components_[0].argsort()[-3:]]  # Top 3 keywords
    return " | ".join(keywords)


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np
from collections import Counter
import re

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    visited = set()

    for i in range(similarity_matrix.shape[0]):
        if i in visited:
            continue
        group = [i]
        visited.add(i)

        for j in range(i + 1, similarity_matrix.shape[0]):
            if similarity_matrix[i, j] > threshold:
                group.append(j)
                visited.add(j)

        similar_groups.append(group)

    return similar_groups

def extract_keywords(questions):
    # Combine all questions in the group into a single string
    combined_text = " ".join(questions)
    # Use regex to remove punctuation and split into words
    words = re.findall(r'\w+', combined_text.lower())
    # Count the frequency of each word
    word_counts = Counter(words)
    # Extract the most common words as keywords
    keywords = word_counts.most_common(3)  # Get top 3 keywords
    # Return a simple group name based on keywords
    return " | ".join(word for word, count in keywords)

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar groups based on threshold
    threshold = 0.8
    similar_groups = find_similar_groups(similarity_matrix, threshold)

    # Display similar question groups with names
    for group in similar_groups:
        questions_in_group = [df_unanswered.iloc[i]['Question'] for i in group]
        group_name = extract_keywords(questions_in_group)
        print(f"Group Name: {group_name}")
        for question in questions_in_group:
            print(f"- {question}")
        print()  # Blank line for better readability

if __name__ == "__main__":
    main()


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_groups(similarity_matrix, threshold=0.8):
    similar_groups = []
    visited = set()
    
    for i in range(similarity_matrix.shape[0]):
        if i in visited:
            continue
        group = [i]
        visited.add(i)
        
        for j in range(i + 1, similarity_matrix.shape[0]):
            if similarity_matrix[i, j] > threshold:
                group.append(j)
                visited.add(j)
        
        similar_groups.append(group)
    
    return similar_groups

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar groups based on threshold
    threshold = 0.8
    similar_groups = find_similar_groups(similarity_matrix, threshold)

    # Display similar question groups
    for group in similar_groups:
        questions_in_group = [df_unanswered.iloc[i]['Question'] for i in group]
        print("Similar Questions Group:")
        for question in questions_in_group:
            print(f"- {question}")
        print()  # Blank line for better readability

if __name__ == "__main__":
    main()

sentence1,sentence2,label
"How do I install Jenkins on Ubuntu?", "What are the steps to set up Jenkins on an Ubuntu server?",1
"How can I create a new repository in Bitbucket?", "What's the process for initializing a repository on Bitbucket?",1
"How to configure Sonarqube for code quality analysis?", "What settings should I adjust in Sonarqube to evaluate code quality?",1
"How do I use Ansible to automate server deployments?", "What are the Ansible commands for automating the deployment of servers?",1
"How to integrate Confluence with Jira?", "What is the method to link Confluence pages to Jira tickets?",1
"How do I troubleshoot Jenkins build failures?", "What steps should I take to fix failed builds in Jenkins?",1
"How to set up Bitbucket pipelines for CI/CD?", "What is the procedure to configure CI/CD pipelines in Bitbucket?",1
"How can Sonarqube help in maintaining code standards?", "In what ways does Sonarqube assist with enforcing coding standards?",1
"How to manage playbooks in Ansible?", "What is the best practice for organizing Ansible playbooks?",1
"How do I create Jira dashboards for project tracking?", "What's the way to set up dashboards in Jira for monitoring projects?",1
"How to secure Jenkins with authentication?", "What methods can I use to add authentication to Jenkins?",1
"How can I merge branches in Bitbucket?", "What's the process for merging different branches in Bitbucket repositories?",1
"How to analyze code smells using Sonarqube?", "What steps do I follow to detect code smells with Sonarqube?",1
"How do I deploy applications using Ansible?", "What are the commands to deploy apps through Ansible?",1
"How to collaborate using Confluence and Jira together?", "What is the way to use Confluence and Jira for team collaboration?",1
"How to resolve Jenkins plugin compatibility issues?", "What should I do if Jenkins plugins are not compatible with each other?",1
"How to set up access controls in Bitbucket?", "What's the method to configure user permissions in Bitbucket?",1
"How can Sonarqube integrate with Jenkins?", "What is the process to connect Sonarqube with Jenkins for continuous integration?",1
"How to write Ansible roles for infrastructure management?", "What steps are involved in creating Ansible roles for managing infrastructure?",1
"How to track issues in Jira using Confluence?", "What is the way to monitor Jira issues through Confluence pages?",1
"How do I update Jenkins to the latest version?", "What's the procedure for upgrading Jenkins to its newest release?",1
"How can I clone a Bitbucket repository locally?", "What commands do I use to clone a repository from Bitbucket to my machine?",1
"How to interpret Sonarqube analysis reports?", "What should I understand from the reports generated by Sonarqube?",1
"How to configure Ansible inventory files?", "What is the method to set up inventory files in Ansible?",1
"How do I create a Confluence space for my team?", "What's the process to establish a new space in Confluence for team collaboration?",1
"How to assign tasks in Jira projects?", "What steps do I follow to allocate tasks within Jira project boards?",1
"How to back up Jenkins configurations?", "What's the way to create backups of Jenkins setup and configurations?",1
"How can I enable branch permissions in Bitbucket?", "What is the method to set branch access controls in Bitbucket?",1
"How to set quality gates in Sonarqube?", "What steps do I take to establish quality gates within Sonarqube?",1
"How do I use Ansible to manage Docker containers?", "What are the Ansible playbooks for handling Docker container deployments?",1
"How to link Jira issues to Confluence documents?", "What's the procedure to associate Jira tickets with Confluence pages?",1


from sentence_transformers import SentenceTransformer, InputExample, losses
from torch.utils.data import DataLoader
import pandas as pd
import torch
import logging

# Enable logging
logging.basicConfig(format='%(asctime)s - %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S',
                    level=logging.INFO)

def main():
    # Step 1: Load the dataset
    df = pd.read_csv('data/similar_questions.csv')

    # Step 2: Prepare the data
    train_examples = []
    for index, row in df.iterrows():
        train_examples.append(
            InputExample(texts=[row['sentence1'], row['sentence2']], label=row['label'])
        )

    # Step 3: Load the pre-trained SBERT model from local directory
    model_path = 'models/all-MiniLM-L6-v2'  # Update this path accordingly
    model = SentenceTransformer(model_path)

    # Step 4: Define the training objective
    # For regression (similarity scores)
    train_loss = losses.CosineSimilarityLoss(model)

    # For classification (binary labels), uncomment the following:
    # train_loss = losses.SoftmaxLoss(model=model, sentence_embedding_dimension=model.get_sentence_embedding_dimension(), num_labels=2)

    # Step 5: Create a DataLoader
    train_dataloader = DataLoader(train_examples, shuffle=True, batch_size=16)

    # Step 6: Fine-tune the model
    num_epochs = 4
    warmup_steps = int(len(train_dataloader) * num_epochs * 0.1)  # 10% of train data

    model.fit(
        train_objectives=[(train_dataloader, train_loss)],
        epochs=num_epochs,
        warmup_steps=warmup_steps,
        device=torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    )

    # Step 7: Save the fine-tuned model
    model.save('models/fine-tuned-sbert')

if __name__ == "__main__":
    main()


from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd
import numpy as np

def load_fine_tuned_model():
    # Load the fine-tuned SBERT model
    model = SentenceTransformer('models/fine-tuned-sbert')
    return model

def generate_embeddings(model, questions):
    embeddings = model.encode(questions, convert_to_tensor=True)
    return embeddings.cpu().numpy()

def find_similar_pairs(similarity_matrix, threshold=0.8):
    similar_pairs = np.argwhere(similarity_matrix > threshold)
    # Remove self-pairs and duplicate pairs
    similar_pairs = [(i, j) for i, j in similar_pairs if i < j]
    return similar_pairs

def main():
    # Load the fine-tuned model
    model = load_fine_tuned_model()

    # Load your unanswered questions
    df_unanswered = pd.read_csv('data/unanswered_questions.csv')  # Update path as needed

    # Generate embeddings
    embeddings = generate_embeddings(model, df_unanswered['Question'].tolist())

    # Compute cosine similarity matrix
    similarity_matrix = cosine_similarity(embeddings)

    # Find similar pairs based on threshold
    threshold = 0.8
    similar_pairs = find_similar_pairs(similarity_matrix, threshold)

    # Display similar question pairs
    for i, j in similar_pairs:
        print(f"Question {i+1} and Question {j+1} are similar:")
        print(f"Q{i+1}: {df_unanswered.iloc[i]['Question']}")
        print(f"Q{j+1}: {df_unanswered.iloc[j]['Question']}\n")

if __name__ == "__main__":
    main()

import pandas as pd
import random

# Load all questions
df = pd.read_csv('similar_questions.csv')

# Separate similar and non-similar questions
similar_df = df[df['label'] == 1]
all_questions = df['sentence1'].tolist() + df['sentence2'].tolist()

# Generate negative samples by pairing questions from different tools
negative_samples = []
tools = ['Jenkins', 'Bitbucket', 'Sonarqube', 'Ansible', 'Confluence', 'Jira']

for _ in range(100):  # Adjust the number as needed
    q1 = random.choice(all_questions)
    q2 = random.choice(all_questions)

    # Ensure questions are from different tools
    if any(tool in q1 for tool in tools) and any(tool in q2 for tool in tools):
        tool_q1 = next((tool for tool in tools if tool in q1), None)
        tool_q2 = next((tool for tool in tools if tool in q2), None)
        if tool_q1 != tool_q2:
            negative_samples.append({'sentence1': q1, 'sentence2': q2, 'label': 0})

# Create DataFrame for negative samples
negative_df = pd.DataFrame(negative_samples)

# Combine with similar questions
final_df = pd.concat([similar_df, negative_df], ignore_index=True)

# Shuffle the dataset
final_df = final_df.sample(frac=1).reset_index(drop=True)

# Save to CSV
final_df.to_csv('similar_questions.csv', index=False)


import os
import xml.etree.ElementTree as ET
import shutil
from typing import List, Tuple, Dict

# Mapping of connector namespaces to their corresponding Maven groupId and artifactId
CONNECTOR_DEPENDENCY_MAP = {
    'http://www.mulesoft.org/schema/mule/http': ('org.mule.connectors', 'mule-http-connector'),
    'http://www.mulesoft.org/schema/mule/db': ('org.mule.connectors', 'mule-db-connector'),
    'http://www.mulesoft.org/schema/mule/file': ('org.mule.connectors', 'mule-file-connector'),
    'http://www.mulesoft.org/schema/mule/ftp': ('org.mule.connectors', 'mule-ftp-connector'),
    'http://www.mulesoft.org/schema/mule/jms': ('org.mule.connectors', 'mule-jms-connector'),
    'http://www.mulesoft.org/schema/mule/vm': ('org.mule.connectors', 'mule-vm-connector'),
    # Add more mappings as needed
}

def parse_domain_resources(domain_path: str) -> Tuple[Dict[str, List[ET.Element]], set]:
    resources = {
        'connectors': [],
        'global_configs': [],
        'error_handlers': [],
        'security_configs': [],
        'schedulers': [],
        'transformers': [],
        'spring_beans': [],
        'other': []
    }
    used_namespaces = set()

    config_path = os.path.join(domain_path, "src", "main", "mule", "mule-domain-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Collect used namespaces
    for key, value in root.attrib.items():
        if key.startswith('xmlns:'):
            used_namespaces.add(value)

    for child in root:
        if '}' in child.tag:
            namespace = child.tag.split('}')[0][1:]  # Extract namespace
            used_namespaces.add(namespace)
            tag = child.tag.split('}')[1]
            if any(x in tag for x in ['config', 'configuration']):
                resources['connectors'].append(child)
            elif tag == 'global-property':
                resources['global_configs'].append(child)
            elif tag == 'error-handler':
                resources['error_handlers'].append(child)
            elif 'security' in tag or 'oauth' in tag:
                resources['security_configs'].append(child)
            elif 'scheduler' in tag:
                resources['schedulers'].append(child)
            elif 'transformer' in tag:
                resources['transformers'].append(child)
            elif tag == 'beans':
                resources['spring_beans'].append(child)
            else:
                resources['other'].append(child)

    return resources, used_namespaces

def update_project_config(project_path: str, resources: Dict[str, List[ET.Element]], used_namespaces: set):
    config_path = os.path.join(project_path, "src", "main", "mule", "mule-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Add all resources to the project config
    for resource_list in resources.values():
        for resource in resource_list:
            root.append(resource)

    # Update namespaces
    for namespace in used_namespaces:
        for prefix, uri in root.attrib.items():
            if uri == namespace:
                break
        else:
            # If namespace not found, add it with a generated prefix
            i = 1
            while f'xmlns:ns{i}' in root.attrib:
                i += 1
            root.set(f'xmlns:ns{i}', namespace)

    tree.write(config_path, encoding="UTF-8", xml_declaration=True)

def update_project_pom(project_path: str, domain_path: str, used_namespaces: set):
    domain_pom_path = os.path.join(domain_path, "pom.xml")
    project_pom_path = os.path.join(project_path, "pom.xml")

    domain_tree = ET.parse(domain_pom_path)
    domain_root = domain_tree.getroot()

    project_tree = ET.parse(project_pom_path)
    project_root = project_tree.getroot()

    # Transfer dependencies
    domain_deps = domain_root.find("./{*}dependencies")
    if domain_deps is not None:
        project_deps = project_root.find("./{*}dependencies")
        if project_deps is None:
            project_deps = ET.SubElement(project_root, "dependencies")

        for dep in domain_deps:
            if dep.find("./{*}classifier") is None or dep.find("./{*}classifier").text != "mule-domain":
                project_deps.append(dep)

    # Add connector dependencies based on used namespaces
    for namespace in used_namespaces:
        if namespace in CONNECTOR_DEPENDENCY_MAP:
            group_id, artifact_id = CONNECTOR_DEPENDENCY_MAP[namespace]
            new_dep = ET.SubElement(project_deps, "dependency")
            ET.SubElement(new_dep, "groupId").text = group_id
            ET.SubElement(new_dep, "artifactId").text = artifact_id
            # You might want to specify a version or use a property for versioning
            # ET.SubElement(new_dep, "version").text = "${mule.version}"

    # Transfer properties
    domain_props = domain_root.find("./{*}properties")
    if domain_props is not None:
        project_props = project_root.find("./{*}properties")
        if project_props is None:
            project_props = ET.SubElement(project_root, "properties")

        for prop in domain_props:
            if not project_props.find(f".//{prop.tag}"):
                project_props.append(prop)

    # Remove domain dependency
    for dep in project_root.findall(".//{*}dependency"):
        artifact_id = dep.find("./{*}artifactId")
        classifier = dep.find("./{*}classifier")
        if (artifact_id is not None and artifact_id.text == "my-domain-project" and
            classifier is not None and classifier.text == "mule-domain"):
            project_deps.remove(dep)

    project_tree.write(project_pom_path, encoding="UTF-8", xml_declaration=True)

def migrate_project(domain_path: str, project_path: str):
    print(f"Migrating project: {os.path.basename(project_path)}")

    # Parse domain resources and collect used namespaces
    resources, used_namespaces = parse_domain_resources(domain_path)

    # Update project configuration
    update_project_config(project_path, resources, used_namespaces)

    # Update project pom
    update_project_pom(project_path, domain_path, used_namespaces)

    # Copy any additional resources
    domain_resources_path = os.path.join(domain_path, "src", "main", "resources")
    project_resources_path = os.path.join(project_path, "src", "main", "resources")
    if os.path.exists(domain_resources_path):
        for item in os.listdir(domain_resources_path):
            s = os.path.join(domain_resources_path, item)
            d = os.path.join(project_resources_path, item)
            if os.path.isfile(s):
                shutil.copy2(s, d)

    print(f"Migration completed for project: {os.path.basename(project_path)}")

def main():
    domain_path = "/path/to/domain/project"
    projects = [
        "/path/to/project1",
        "/path/to/project2",
        # Add more project paths as needed
    ]

    for project_path in projects:
        migrate_project(domain_path, project_path)

if __name__ == "__main__":
    main()


