import os
import xml.etree.ElementTree as ET
import shutil
from typing import List, Tuple, Dict

# Mapping of connector namespaces to their corresponding Maven groupId and artifactId
CONNECTOR_DEPENDENCY_MAP = {
    'http://www.mulesoft.org/schema/mule/http': ('org.mule.connectors', 'mule-http-connector'),
    'http://www.mulesoft.org/schema/mule/db': ('org.mule.connectors', 'mule-db-connector'),
    'http://www.mulesoft.org/schema/mule/file': ('org.mule.connectors', 'mule-file-connector'),
    'http://www.mulesoft.org/schema/mule/ftp': ('org.mule.connectors', 'mule-ftp-connector'),
    'http://www.mulesoft.org/schema/mule/jms': ('org.mule.connectors', 'mule-jms-connector'),
    'http://www.mulesoft.org/schema/mule/vm': ('org.mule.connectors', 'mule-vm-connector'),
    # Add more mappings as needed
}

def parse_domain_resources(domain_path: str) -> Tuple[Dict[str, List[ET.Element]], set]:
    resources = {
        'connectors': [],
        'global_configs': [],
        'error_handlers': [],
        'security_configs': [],
        'schedulers': [],
        'transformers': [],
        'spring_beans': [],
        'other': []
    }
    used_namespaces = set()

    config_path = os.path.join(domain_path, "src", "main", "mule", "mule-domain-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Collect used namespaces
    for key, value in root.attrib.items():
        if key.startswith('xmlns:'):
            used_namespaces.add(value)

    for child in root:
        if '}' in child.tag:
            namespace = child.tag.split('}')[0][1:]  # Extract namespace
            used_namespaces.add(namespace)
            tag = child.tag.split('}')[1]
            if any(x in tag for x in ['config', 'configuration']):
                resources['connectors'].append(child)
            elif tag == 'global-property':
                resources['global_configs'].append(child)
            elif tag == 'error-handler':
                resources['error_handlers'].append(child)
            elif 'security' in tag or 'oauth' in tag:
                resources['security_configs'].append(child)
            elif 'scheduler' in tag:
                resources['schedulers'].append(child)
            elif 'transformer' in tag:
                resources['transformers'].append(child)
            elif tag == 'beans':
                resources['spring_beans'].append(child)
            else:
                resources['other'].append(child)

    return resources, used_namespaces

def update_project_config(project_path: str, resources: Dict[str, List[ET.Element]], used_namespaces: set):
    config_path = os.path.join(project_path, "src", "main", "mule", "mule-config.xml")
    tree = ET.parse(config_path)
    root = tree.getroot()

    # Add all resources to the project config
    for resource_list in resources.values():
        for resource in resource_list:
            root.append(resource)

    # Update namespaces
    for namespace in used_namespaces:
        for prefix, uri in root.attrib.items():
            if uri == namespace:
                break
        else:
            # If namespace not found, add it with a generated prefix
            i = 1
            while f'xmlns:ns{i}' in root.attrib:
                i += 1
            root.set(f'xmlns:ns{i}', namespace)

    tree.write(config_path, encoding="UTF-8", xml_declaration=True)

def update_project_pom(project_path: str, domain_path: str, used_namespaces: set):
    domain_pom_path = os.path.join(domain_path, "pom.xml")
    project_pom_path = os.path.join(project_path, "pom.xml")

    domain_tree = ET.parse(domain_pom_path)
    domain_root = domain_tree.getroot()

    project_tree = ET.parse(project_pom_path)
    project_root = project_tree.getroot()

    # Transfer dependencies
    domain_deps = domain_root.find("./{*}dependencies")
    if domain_deps is not None:
        project_deps = project_root.find("./{*}dependencies")
        if project_deps is None:
            project_deps = ET.SubElement(project_root, "dependencies")

        for dep in domain_deps:
            if dep.find("./{*}classifier") is None or dep.find("./{*}classifier").text != "mule-domain":
                project_deps.append(dep)

    # Add connector dependencies based on used namespaces
    for namespace in used_namespaces:
        if namespace in CONNECTOR_DEPENDENCY_MAP:
            group_id, artifact_id = CONNECTOR_DEPENDENCY_MAP[namespace]
            new_dep = ET.SubElement(project_deps, "dependency")
            ET.SubElement(new_dep, "groupId").text = group_id
            ET.SubElement(new_dep, "artifactId").text = artifact_id
            # You might want to specify a version or use a property for versioning
            # ET.SubElement(new_dep, "version").text = "${mule.version}"

    # Transfer properties
    domain_props = domain_root.find("./{*}properties")
    if domain_props is not None:
        project_props = project_root.find("./{*}properties")
        if project_props is None:
            project_props = ET.SubElement(project_root, "properties")

        for prop in domain_props:
            if not project_props.find(f".//{prop.tag}"):
                project_props.append(prop)

    # Remove domain dependency
    for dep in project_root.findall(".//{*}dependency"):
        artifact_id = dep.find("./{*}artifactId")
        classifier = dep.find("./{*}classifier")
        if (artifact_id is not None and artifact_id.text == "my-domain-project" and
            classifier is not None and classifier.text == "mule-domain"):
            project_deps.remove(dep)

    project_tree.write(project_pom_path, encoding="UTF-8", xml_declaration=True)

def migrate_project(domain_path: str, project_path: str):
    print(f"Migrating project: {os.path.basename(project_path)}")

    # Parse domain resources and collect used namespaces
    resources, used_namespaces = parse_domain_resources(domain_path)

    # Update project configuration
    update_project_config(project_path, resources, used_namespaces)

    # Update project pom
    update_project_pom(project_path, domain_path, used_namespaces)

    # Copy any additional resources
    domain_resources_path = os.path.join(domain_path, "src", "main", "resources")
    project_resources_path = os.path.join(project_path, "src", "main", "resources")
    if os.path.exists(domain_resources_path):
        for item in os.listdir(domain_resources_path):
            s = os.path.join(domain_resources_path, item)
            d = os.path.join(project_resources_path, item)
            if os.path.isfile(s):
                shutil.copy2(s, d)

    print(f"Migration completed for project: {os.path.basename(project_path)}")

def main():
    domain_path = "/path/to/domain/project"
    projects = [
        "/path/to/project1",
        "/path/to/project2",
        # Add more project paths as needed
    ]

    for project_path in projects:
        migrate_project(domain_path, project_path)

if __name__ == "__main__":
    main()


module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

import base64
from email import policy
from email.parser import BytesParser
from io import BytesIO

# Function to handle the conversion of an image to a data URI
def get_image_data_uri(part):
    image_content = part.get_payload(decode=True)
    image_type = part.get_content_subtype()
    base64_image = base64.b64encode(image_content).decode('utf-8')
    return f"data:image/{image_type};base64,{base64_image}"

# Function to convert text/plain to HTML (if needed)
def convert_plain_text_to_html(plain_text):
    html_content = "<html><body><pre style='font-family: monospace;'>{}</pre></body></html>"
    return html_content.format(plain_text)

# Function to convert email to HTML with correctly embedded images
def email_to_html_with_images_or_text(msg):
    html_parts = []
    image_cid_map = {}

    # First pass: Extract images and build a map of cid references to data URIs
    for part in msg.walk():
        content_type = part.get_content_type()
        if "image" in content_type:
            # Get the content ID (cid) and strip surrounding angle brackets if present
            cid = part.get("Content-ID")
            if cid:
                cid = cid.strip('<>')
                image_cid_map[cid] = get_image_data_uri(part)

    # Second pass: Build the HTML and replace cid references with the corresponding data URIs
    for part in msg.walk():
        content_type = part.get_content_type()
        if content_type == "text/html":
            html_content = part.get_payload(decode=True).decode(part.get_content_charset())
            # Replace all cid references with data URIs
            for cid, data_uri in image_cid_map.items():
                html_content = html_content.replace(f'cid:{cid}', data_uri)
            html_parts.append(html_content)

    return ''.join(html_parts)

# Simulate reading and processing an email (this is where you'd provide the actual email)
# email_content = b"Your raw MIME email content here"
# msg = BytesParser(policy=


from io import BytesIO
from email import policy
from email.parser import BytesParser

# Simulating reading an email (In real scenario, load from file or other source)
email_content = b"""Your raw MIME email content here"""

# Parsing the email
msg = BytesParser(policy=policy.default).parsebytes(email_content)

# Function to convert text/plain to HTML
def convert_plain_text_to_html(plain_text):
    html_content = "<html><body><pre style='font-family: monospace;'>{}</pre></body></html>"
    return html_content.format(plain_text)

# Function to convert email to HTML with embedded images (or plain text handling)
def email_to_html_with_images_or_text(msg):
    html_parts = []
    for part in msg.walk():
        content_type = part.get_content_type()
        if content_type == "text/html":
            html_parts.append(part.get_payload(decode=True).decode(part.get_content_charset()))
        elif content_type == "text/plain":
            plain_text = part.get_payload(decode=True).decode(part.get_content_charset())
            html_parts.append(convert_plain_text_to_html(plain_text))
        elif "image" in content_type:
            image_data_uri = get_image_data_uri(part)
            html_parts.append(f'<img src="{image_data_uri}"/>')

    return ''.join(html_parts)

# Convert and store HTML
html_output = email_to_html_with_images_or_text(msg)

# For demonstration, we're using BytesIO as in-memory file
html_file = BytesIO(html_output.encode('utf-8'))
html_file.seek(0)  # Rewind to the beginning of the file
print(html_file.read().decode('utf-8'))  # Print the HTML content for demonstration


Monitor and Restart:
Given the Flask application is not running
When the monitoring system checks the application status
Then the system should restart the application using nohup
Log Management:
Given the Flask application is running and logging output
When a new day starts
Then the system should create a new log file for that day
Given log files older than 7 days exist
When the system performs its daily check
Then it should delete these old log files
Persistence:
Given the server has just booted up
When the operating system has finished loading
Then the monitoring system should start automatically
Usability:
Given a new developer wants to use the monitoring system
When they read the provided instructions
Then they should be able to set up and configure the system without additional assistance
Testing:
Given the Flask application is running and being monitored
When the application is manually terminated to simulate a crash
Then the monitoring system should detect this and restart the application within one minute

Acceptance Criteria in Given-When-Then Format
Given I am subscribed to the mailbox,
When a new email arrives,
Then the system should immediately trigger the callback function.

Given a new email has triggered the callback function,
When the email is processed,
Then it should be processed within seconds of its arrival without manual intervention.

Given the email notification system is operational,
When new emails arrive,
Then all new emails should be detected and processed accurately, with no emails missed or processed more than once.

Given the system is set up for testing,
When rapid successive emails are simulated to arrive,
Then the system should handle them without crashing or missing any emails.

Given typical system usage,
When the system processes incoming emails,
Then it should remain stable and perform within the expected parameters.


Acceptance Criteria in Given-When-Then Format
Detect and Convert Images:

Given an email with attached images,
When the email is processed,
Then the tool should recognize all images and convert each image into a data URI format.
Embed Images in HTML:

Given images have been converted to data URIs,
When the email is converted to HTML,
Then all images must appear as <img> tags at their correct positions within the content, and the HTML should visually match the original email including all text and images.
Content Accuracy:

Given an email is being converted to HTML,
When the conversion process is complete,
Then the HTML should maintain the original email's layout and formatting without losing any parts of the email such as text or images.
Handle Various Emails:

Given emails with multiple images,
When these emails are processed,
Then the tool should successfully convert all images and the text content.
And Given emails without any images,
When these emails are processed,
Then the tool should ensure the text content is still properly converted to HTML.
Testing:

Given the system is set for testing,
When emails are processed through the system,
Then tests should confirm that images are correctly detected and embedded.
And the HTML output should accurately reflect the content and structure of the original email.

Want an automated system to monitor and restart our Flask application
So that the application remains available even after server restarts or unexpected crashes


Our MMBot and JiraBot on a development server. Currently, the application is started manually using nohup python server.py.
However, this approach doesn't ensure the application's continuous availability, especially after server restarts or if the application crashes unexpectedly.
We need a robust solution that automatically monitors the application's status and restarts it when necessary, while also managing log files efficiently


Monitor and Restart:
Automatically check if the Flask app is running every minute
Restart the app using nohup if it's not running


Log Management:
Append all outputs to a log file
Rotate log files daily


Persistence:
The monitoring system starts automatically on server boot
Continues running until manually stopped


Usability:
Provide simple instructions for setup and use
Allow easy configuration of app name and log directory


Testing:
Demonstrate successful app restart after a simulated crash


Title: Enhance Email-to-HTML Conversion to Include Embedded Images

Description
As a user, I want the email-to-HTML conversion process to include images embedded within the email so that the resulting
HTML is a complete and accurate representation of the original email content.

Currently, our tool converts email text to HTML but does not handle images, resulting in missing visual information in the converted files.
The enhancement will modify our existing script to detect and embed images as data URIs directly in the HTML,
ensuring that the output is self-contained and visually consistent with the original email.

Acceptance Criteria

Detect and Convert Images:
The tool should recognize all images attached in the email.
Each image should be converted into a data URI format.

Embed Images in HTML:
Images must appear in the HTML as <img> tags at the correct points in the content.
The HTML should look like the original email, with all text and images in place.

Content Accuracy:
The converted HTML should maintain the original email's layout and formatting.
Ensure that no parts of the email, such as text or images, are lost in conversion.

Handle Various Emails:
The tool should successfully convert emails that have multiple images.
It should also handle emails without any images, ensuring the text content is still properly converted to HTML.

Testing:
Ensure the HTML output accurately reflects the content and structure of the original email.


Title: Implement Subscription-Based Email Notification System

Description
As a user, I want the system to notify me immediately when a new email arrives so that I can process emails in real-time, reducing the response time and system load compared to the current long polling method.

Acceptance Criteria

Subscription Setup:
The system must subscribe to new email notifications.
New emails should trigger a callback function.

Real-Time Processing:
The system should process emails within seconds of their arrival.
Ensure that each new email triggers the designated processing logic without user intervention.

Accuracy:
All new emails must be detected and processed.
No emails should be missed or processed more than once.

Testing:
Testing should confirm that the system handles rapid successive email arrivals.


import base64
from email import policy
from email.parser import BytesParser
from io import BytesIO

# Simulating reading an email with images (In real scenario, load from file or other source)
email_content = b"""Your raw MIME email content here"""

# Parsing the email
msg = BytesParser(policy=policy.default).parsebytes(email_content)

# Function to handle the conversion of an image to a data URI
def get_image_data_uri(part):
    image_content = part.get_payload(decode=True)
    image_type = part.get_content_subtype()
    base64_image = base64.b64encode(image_content).decode('utf-8')
    return f"data:image/{image_type};base64,{base64_image}"

# Function to convert email to HTML with embedded images
def email_to_html_with_images(msg):
    html_parts = []
    for part in msg.walk():
        content_type = part.get_content_type()
        if content_type == "text/html":
            html_parts.append(part.get_payload(decode=True).decode(part.get_content_charset()))
        elif "image" in content_type:
            image_data_uri = get_image_data_uri(part)
            html_parts.append(f'<img src="{image_data_uri}"/>')

    return ''.join(html_parts)

# Convert and store HTML
html_output = email_to_html_with_images(msg)

# For demonstration, we're using BytesIO as in-memory file
html_file = BytesIO(html_output.encode('utf-8'))
html_file.seek(0)  # Rewind to the beginning of the file
print(html_file.read().decode('utf-8'))  # Print the HTML content for demonstration


#!/bin/bash

APP_NAME="app.py"
LOG_DIR="/path/to/your/logs"
LOG_FILE="$LOG_DIR/app_$(date +%Y%m%d).log"

# Create log directory if it doesn't exist
mkdir -p "$LOG_DIR"

# Function to get current log file name
get_log_file() {
    echo "$LOG_DIR/app_$(date +%Y%m%d).log"
}

while true
do
    # Update log file name
    LOG_FILE=$(get_log_file)

    if ! pgrep -f "$APP_NAME" > /dev/null
    then
        echo "Starting $APP_NAME at $(date)" >> "$LOG_FILE"
        nohup python "$APP_NAME" >> "$LOG_FILE" 2>&1 &
    fi

    # Optional: Delete logs older than 7 days
    find "$LOG_DIR" -name "app_*.log" -type f -mtime +7 -delete

    sleep 60
done


1. Code Carbon Inefficiency Scanner

Problem Statement: Develop a tool that scans existing codebases to identify carbon inefficiencies. This scanner should be capable of analyzing code structure, detecting inefficient algorithms, and flagging practices that lead to excessive energy consumption.
Practicality: This is a feasible project, especially with a focus on integrating existing static analysis tools and expanding them to include energy efficiency metrics. The challenge will be in defining the criteria for "carbon inefficiency" and ensuring the scanner provides actionable feedback.
2. IDE Plugin for Carbon Efficiency

Problem Statement: Create an interactive framework that integrates into popular IDEs (like VSCode or IntelliJ) as a plugin. The plugin should highlight carbon inefficiencies in real-time as developers write code, offering suggestions for more efficient alternatives.
Practicality: Building an IDE plugin is achievable, but the effectiveness depends on the robustness of the underlying analysis engine. Leveraging existing tools or APIs like CodeCarbon could help expedite development, but significant customization will be needed to provide real-time feedback.
3. Carbon Efficiency Dashboard

Problem Statement: Design a dashboard that wraps around the CodeCarbon tool, providing visual insights into the carbon impact of code during development, testing, and deployment stages. The dashboard should offer historical data, trends, and actionable insights.
Practicality: This is practical and could be implemented by extending CodeCarbon’s existing capabilities. The key challenge will be ensuring the dashboard is intuitive and provides meaningful, actionable data for developers and managers.
4. Process-Intensive Task Optimization

Problem Statement: Identify process-intensive tasks within the software development lifecycle (e.g., build time, merge time, test execution time) and develop solutions to minimize their carbon footprint. This could involve optimizing build pipelines, reducing redundant testing, or parallelizing tasks more effectively.
Practicality: This is highly practical and aligns well with DevOps practices. The main challenge will be in measuring the carbon footprint of these processes accurately and finding optimization techniques that are universally applicable.
5. Code Optimizer Tool

Problem Statement: Create a tool that automatically converts inefficient code into a more carbon-efficient version. The tool should be capable of refactoring code, optimizing algorithms, and suggesting alternative approaches to reduce energy consumption.
Practicality: This is an ambitious but potentially groundbreaking project. Developing such a tool would require a deep understanding of different programming languages and the ability to analyze and refactor code without introducing bugs. Starting with a more limited scope, such as optimizing specific patterns, could make this more manageable.
6. Open Frameworks for Code Optimization

Problem Statement: Develop or identify frameworks outside the traditional scope that can help optimize code for energy efficiency. This could involve leveraging AI/ML for code analysis, exploring new paradigms for energy-efficient software design, or integrating sustainability metrics into existing frameworks.
Practicality: This is a broad and exploratory problem statement. The practical approach would be to focus on a specific area within this framework and develop a proof of concept. Collaborating with researchers or open-source communities could provide valuable insights and accelerate progress.


Objective:
The Green Computing Hackathon Challenge is designed to spark curiosity and innovation among developers by focusing on energy-efficient programming practices.
Participants will engage in various coding tasks aimed at optimizing software for reduced energy consumption, all within the confines of BAND laptops.
This hackathon encourages hands-on learning and application of green computing concepts without requiring additional infrastructure.

Themes:

Theme 1: Energy Efficiency Comparisons

Comparing Energy Efficiency: REST vs gRPC
Develop a comprehensive benchmarking suite to compare the energy efficiency of gRPC-based Protocol Buffers applications with traditional REST/JSON applications. The goal is to quantify the energy savings and performance improvements that can be achieved by using gRPC over REST/JSON for different types of operations and data loads.

Comparing Energy Efficiency: Native Compiled vs. VM Compiled vs. Interpreted Languages
Develop a comprehensive benchmarking suite to compare the energy efficiency of native compiled languages (e.g., Rust, C++), compiled languages running on a virtual machine (e.g., Java, C#), and interpreted languages (e.g., Python, Ruby, etc.). The goal is to measure and analyze the energy consumption, performance, and resource utilization of various computational tasks implemented in these different types of languages.

Theme 2: Green Coding Practices
Guide for Green Coding Practices:
Develop an interactive guide that educates users on green coding practices. The guide should provide practical tips, real-time feedback, and educational resources to promote energy-efficient coding and software operations.

Theme 3: Code Optimization
Optimizing Legacy Code for Energy Efficiency:
Take a piece of legacy code (available in various languages) and optimize it for energy efficiency. Participants should measure the energy consumption before and after optimization and provide detailed reports on their improvements.


Theme 4: Algorithm and Data Structure Efficiency
Energy-Efficient Algorithms
Implement common algorithms (e.g., sorting, searching, graph traversal) in the most energy-efficient way possible. Compare different implementations to find the most energy-efficient solution.

Sustainable Data Structures
Analyze and implement different data structures to determine which are the most energy-efficient for various operations (e.g., insertions, deletions, searches). Provide a comparative study.

Goal:
By the end of the hackathon, participants will have developed a deeper understanding of green computing practices, learned to optimize code for energy efficiency, and created solutions that contribute to a more sustainable future. The focus is on practical, hands-on experience that can be immediately applied to real-world software development scenarios.

Impact:
This hackathon aims to promote environmentally conscious coding practices, reduce the carbon footprint of software applications, and encourage a culture of sustainability within the developer community.