import java.util.*;
import java.io.*;
import java.util.concurrent.*;

public class CarbonEfficiencyExamples {

    // 1. Inefficient loops
    static int inefficientLoop(int n) {
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                result += i * j;
            }
        }
        return result;
    }

    static int efficientLoop(int n) {
        return IntStream.range(0, n)
                .flatMap(i -> IntStream.range(0, n).map(j -> i * j))
                .sum();
    }

    // 2. Redundant computations
    static List<Integer> inefficientRedundant(List<Integer> data) {
        List<Integer> result = new ArrayList<>();
        for (int item : data) {
            result.add(data.size() * item);
        }
        return result;
    }

    static List<Integer> efficientRedundant(List<Integer> data) {
        int size = data.size();
        return data.stream().map(item -> size * item).collect(Collectors.toList());
    }

    // 3. Improper data structures
    static boolean inefficientLookup(List<Integer> data, int target) {
        for (int item : data) {
            if (item == target) {
                return true;
            }
        }
        return false;
    }

    static boolean efficientLookup(List<Integer> data, int target) {
        return new HashSet<>(data).contains(target);
    }

    // 4. Memory leaks (simulated in Java)
    static class ResourceManager {
        private byte[] resource = new byte[1024 * 1024]; // 1MB
    }

    static void inefficientResourceUsage() {
        List<ResourceManager> managers = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            managers.add(new ResourceManager());
        }
        // Resources are never released
    }

    static void efficientResourceUsage() {
        for (int i = 0; i < 1000; i++) {
            ResourceManager manager = new ResourceManager();
            // Use the manager
            manager = null; // Allow for garbage collection
        }
        System.gc(); // Suggest garbage collection
    }

    // 5. Inefficient string concatenation
    static String inefficientStringConcat(int n) {
        String result = "";
        for (int i = 0; i < n; i++) {
            result += i;
        }
        return result;
    }

    static String efficientStringConcat(int n) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }
        return sb.toString();
    }

    // 6. Excessive I/O operations
    static void inefficientFileIO(String filename, List<String> data) throws IOException {
        for (String item : data) {
            try (FileWriter fw = new FileWriter(filename, true);
                 BufferedWriter bw = new BufferedWriter(fw);
                 PrintWriter out = new PrintWriter(bw)) {
                out.println(item);
            }
        }
    }

    static void efficientFileIO(String filename, List<String> data) throws IOException {
        try (FileWriter fw = new FileWriter(filename);
             BufferedWriter bw = new BufferedWriter(fw);
             PrintWriter out = new PrintWriter(bw)) {
            for (String item : data) {
                out.println(item);
            }
        }
    }

    // 7. Unoptimized database queries (using JDBC as an example)
    static List<String> inefficientDBQuery(Connection conn) throws SQLException {
        List<String> results = new ArrayList<>();
        for (int id = 1; id <= 100; id++) {
            try (PreparedStatement stmt = conn.prepareStatement("SELECT name FROM users WHERE id = ?")) {
                stmt.setInt(1, id);
                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        results.add(rs.getString("name"));
                    }
                }
            }
        }
        return results;
    }

    static List<String> efficientDBQuery(Connection conn) throws SQLException {
        List<String> results = new ArrayList<>();
        try (PreparedStatement stmt = conn.prepareStatement("SELECT name FROM users WHERE id BETWEEN 1 AND 100");
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                results.add(rs.getString("name"));
            }
        }
        return results;
    }

    // 8. Inefficient use of libraries
    static void inefficientSleep() throws InterruptedException {
        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000);
        }
    }

    static void efficientSleep() throws InterruptedException {
        Thread.sleep(5000);
    }

    // 9. Poor parallelization
    static void inefficientParallel() throws InterruptedException {
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(() -> results.add(expensiveOperation()));
            thread.start();
            thread.join(); // Wait for each thread to finish before starting the next
        }
    }

    static void efficientParallel() throws InterruptedException {
        List<Thread> threads = new ArrayList<>();
        List<Integer> results = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(() -> results.add(expensiveOperation()));
            threads.add(thread);
            thread.start();
        }
        for (Thread thread : threads) {
            thread.join();
        }
    }

    // 10. Unnecessary computations
    static void inefficientComputation(List<Double> data) {
        double total = data.stream().mapToDouble(Double::doubleValue).sum();
        double average = total / data.size();
        for (double item : data) {
            System.out.printf("%f: %.2f%% of total%n", item, (item / total) * 100);
            System.out.printf("%f: %.2f%% from average%n", item, (item - average) / average * 100);
        }
    }

    static void efficientComputation(List<Double> data) {
        double total = data.stream().mapToDouble(Double::doubleValue).sum();
        double average = total / data.size();
        for (double item : data) {
            double percentOfTotal = (item / total) * 100;
            double percentFromAverage = (item - average) / average * 100;
            System.out.printf("%f: %.2f%% of total, %.2f%% from average%n",
                              item, percentOfTotal, percentFromAverage);
        }
    }

    // Helper method for parallel examples
    private static int expensiveOperation() {
        // Simulate an expensive operation
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new Random().nextInt(100);
    }
}

# 1. Inefficient loops
def inefficient_loop(n):
    result = 0
    for i in range(n):
        for j in range(n):
            result += i * j
    return result

def efficient_loop(n):
    return sum(i * j for i in range(n) for j in range(n))

# 2. Redundant computations
def inefficient_redundant(data):
    result = []
    for item in data:
        result.append(len(data) * item)
    return result

def efficient_redundant(data):
    length = len(data)
    return [length * item for item in data]

# 3. Improper data structures
def inefficient_lookup(data, target):
    for item in data:
        if item == target:
            return True
    return False

def efficient_lookup(data, target):
    return target in set(data)

# 4. Memory leaks (simulated in Python)
class ResourceManager:
    def __init__(self):
        self.resource = "Some large data"

def inefficient_resource_usage():
    managers = []
    for _ in range(1000):
        managers.append(ResourceManager())
    # Resource is never released

def efficient_resource_usage():
    for _ in range(1000):
        manager = ResourceManager()
        # Use the manager
        del manager  # Explicitly delete to release resources

# 5. Inefficient string concatenation
def inefficient_string_concat(n):
    result = ""
    for i in range(n):
        result += str(i)
    return result

def efficient_string_concat(n):
    return ''.join(str(i) for i in range(n))

# 6. Excessive I/O operations
def inefficient_file_io(filename, data):
    for item in data:
        with open(filename, 'a') as f:
            f.write(str(item) + '\n')

def efficient_file_io(filename, data):
    with open(filename, 'w') as f:
        f.write('\n'.join(map(str, data)))

# 7. Unoptimized database queries (using SQLite as an example)
import sqlite3

def inefficient_db_query(db_name):
    conn = sqlite3.connect(db_name)
    cursor = conn.cursor()
    results = []
    for id in range(1, 101):
        cursor.execute("SELECT * FROM users WHERE id = ?", (id,))
        results.append(cursor.fetchone())
    conn.close()
    return results

def efficient_db_query(db_name):
    conn = sqlite3.connect(db_name)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id BETWEEN 1 AND 100")
    results = cursor.fetchall()
    conn.close()
    return results

# 8. Inefficient use of libraries
import time

def inefficient_sleep():
    for _ in range(5):
        time.sleep(1)

def efficient_sleep():
    time.sleep(5)

# 9. Poor parallelization
import threading

def inefficient_parallel():
    results = []
    for i in range(10):
        thread = threading.Thread(target=lambda: results.append(expensive_operation()))
        thread.start()
        thread.join()  # Waiting for each thread to finish before starting the next

def efficient_parallel():
    threads = []
    results = []
    for _ in range(10):
        thread = threading.Thread(target=lambda: results.append(expensive_operation()))
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()

# 10. Unnecessary computations
def inefficient_computation(data):
    total = sum(data)
    average = total / len(data)
    for item in data:
        print(f"{item}: {(item / total) * 100}% of total")
        print(f"{item}: {(item - average) / average * 100}% from average")

def efficient_computation(data):
    total = sum(data)
    average = total / len(data)
    for item in data:
        percent_of_total = (item / total) * 100
        percent_from_average = (item - average) / average * 100
        print(f"{item}: {percent_of_total}% of total, {percent_from_average}% from average")




 # Carbon Efficiency Scanner Development Plan

 ## 1. Define the Scope and Goals

 - Determine target languages (e.g., Java, Python, JavaScript)
 - Define types of inefficiencies to detect (e.g., algorithmic, resource usage, I/O operations)
 - Set measurable goals (e.g., detection accuracy, performance targets)

 ## 2. Choose a Framework or Build from Scratch

 - Evaluate existing static analysis tools (e.g., SonarQube, PMD)
 - Consider building on top of compiler frameworks (e.g., LLVM)
 - Assess trade-offs between using existing tools and building custom solutions

 ## 3. Design the Architecture

 - Create a modular design for extensibility
 - Components to consider:
   - Code parser
   - Abstract Syntax Tree (AST) analyzer
   - Pattern matching engine
   - Inefficiency detection modules
   - Reporting system
   - Suggestion generator

 ## 4. Develop Core Functionality

 ### 4.1 Code Parsing
 - Implement or integrate parsers for target languages
 - Generate ASTs for further analysis

 ### 4.2 Pattern Matching Engine
 - Develop a flexible system to define and detect code patterns
 - Include capability for both syntactic and semantic analysis

 ### 4.3 Inefficiency Detection Modules
 - Create separate modules for each type of inefficiency:
   - Algorithmic inefficiencies (e.g., poor choice of data structures, inefficient loops)
   - Resource usage (e.g., memory leaks, excessive object creation)
   - I/O operations (e.g., unoptimized database queries, inefficient file operations)
   - Parallelization issues
   - Language-specific anti-patterns

 ### 4.4 Carbon Impact Estimation
 - Research and implement models to estimate carbon impact of code
 - Consider factors like CPU usage, memory consumption, and I/O operations

 ### 4.5 Reporting System
 - Design a clear, actionable reporting format
 - Include severity levels, explanations, and improvement suggestions

 ## 5. Implement Language-Specific Features
 - Adapt core functionality to specific languages
 - Develop language-specific detection rules and suggestions

 ## 6. Create User Interface
 - Command-line interface for integration into CI/CD pipelines
 - Consider a graphical interface for interactive use
 - Implement IDE plugins for real-time feedback

 ## 7. Testing and Validation
 - Develop a comprehensive test suite
 - Create benchmarks to measure scanner performance
 - Validate carbon impact estimations against real-world measurements

 ## 8. Documentation and User Guides
 - Write clear documentation for users and contributors
 - Create guides for interpreting results and implementing suggestions

 ## 9. Continuous Improvement
 - Implement a feedback system for false positives/negatives
 - Regularly update inefficiency patterns based on new research and user feedback
 - Continuously refine carbon impact estimation models

 ## 10. Integration and Deployment
 - Develop plugins for popular IDEs and code editors
 - Create integrations with CI/CD tools (e.g., Jenkins, GitLab CI)
 - Consider offering the tool as a cloud service for easier adoption

 ## 11. Community and Ecosystem
 - Open-source the project to encourage contributions
 - Build a community around carbon-efficient coding practices
 - Collaborate with green computing initiatives and research institutions

Custom Python: 0.007662783478812202 kg CO2
Pandas: 0.002304472819277433 kg CO2
Polars: 0.0006235562998289666 kg CO2


Analysis:
Custom Python vs. Pandas: (231%)
The custom Python code emits approximately 231% more CO2 compared to pandas. This substantial increase can be attributed to the less efficient data handling and computation in plain Python, as pandas is optimized for such operations with its underlying use of Cython and NumPy.

Custom Python vs. Polars: (1128%)
The custom Python code emits approximately 1128% more CO2 compared to polars. This massive difference highlights polars' efficiency, especially given its design to utilize modern hardware capabilities effectively, such as multi-threading and columnar data processing.

Pandas vs. Polars: (73%)
As discussed earlier, polars is about 73% more carbon efficient than pandas. This indicates that for large-scale data processing tasks, using polars could lead to significant reductions in carbon emissions.